/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Directive, ElementRef, NgZone, Input, Output, NgModule, Renderer2, Injectable, Component } from '@angular/core';
import Draggable from '@telerik/kendo-draggable';
import { CommonModule } from '@angular/common';
import { auditTime } from 'rxjs/operators';
import { merge, fromEvent, from } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
const isDocumentAvailable = () => typeof document !== 'undefined';

const isChanged = (propertyName, changes, skipFirstChange = true) => (typeof changes[propertyName] !== 'undefined' &&
    (!changes[propertyName].isFirstChange() || !skipFirstChange) &&
    changes[propertyName].previousValue !== changes[propertyName].currentValue);

const anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));

const hasObservers = (emitter) => emitter && emitter.observers.length > 0;

const guid = () => {
    let id = "";
    for (let i = 0; i < 32; i++) {
        const random = Math.random() * 16 | 0; // tslint:disable-line:no-bitwise
        if (i === 8 || i === 12 || i === 16 || i === 20) {
            id += "-";
        }
        // tslint:disable-next-line:no-bitwise
        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }
    return id;
};

class DraggableDirective {
    constructor(element, ngZone) {
        this.element = element;
        this.ngZone = ngZone;
        this.enableDrag = true;
        this.kendoPress = new EventEmitter();
        this.kendoDrag = new EventEmitter();
        this.kendoRelease = new EventEmitter();
    }
    ngOnInit() {
        this.toggleDraggable();
    }
    ngOnChanges(changes) {
        if (isChanged('enableDrag', changes)) {
            this.toggleDraggable();
        }
    }
    ngOnDestroy() {
        this.destroyDraggable();
    }
    toggleDraggable() {
        if (isDocumentAvailable()) {
            this.destroyDraggable();
            if (this.enableDrag) {
                this.draggable = new Draggable({
                    drag: (e) => this.kendoDrag.next(e),
                    press: (e) => this.kendoPress.next(e),
                    release: (e) => this.kendoRelease.next(e)
                });
                this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
            }
        }
    }
    destroyDraggable() {
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    }
}
DraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [["", "kendoDraggable", ""]], inputs: { enableDrag: "enableDrag" }, outputs: { kendoPress: "kendoPress", kendoDrag: "kendoDrag", kendoRelease: "kendoRelease" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
DraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
DraggableDirective.propDecorators = {
    enableDrag: [{ type: Input }],
    kendoPress: [{ type: Output }],
    kendoDrag: [{ type: Output }],
    kendoRelease: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoDraggable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { enableDrag: [{
            type: Input
        }], kendoPress: [{
            type: Output
        }], kendoDrag: [{
            type: Output
        }], kendoRelease: [{
            type: Output
        }] }); })();

/**
 * @hidden
 */
class DraggableModule {
}
DraggableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DraggableModule });
DraggableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DraggableModule_Factory(t) { return new (t || DraggableModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DraggableModule, { declarations: function () { return [DraggableDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DraggableDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DraggableModule, [{
        type: NgModule,
        args: [{
                declarations: [DraggableDirective],
                exports: [DraggableDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();

/* tslint:disable:no-input-rename */
/**
 * @hidden
 */
class EventsOutsideAngularDirective {
    constructor(element, ngZone, renderer) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.events = {};
    }
    ngOnInit() {
        if (!this.element || !this.element.nativeElement) {
            return;
        }
        const events = this.events;
        this.subscriptions = [];
        this.ngZone.runOutsideAngular(() => {
            for (let name in events) {
                if (events.hasOwnProperty(name)) {
                    this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));
                }
            }
        });
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            for (let idx = 0; idx < this.subscriptions.length; idx++) {
                this.subscriptions[idx]();
            }
            this.subscriptions = null;
        }
    }
}
EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) { return new (t || EventsOutsideAngularDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
EventsOutsideAngularDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EventsOutsideAngularDirective, selectors: [["", "kendoEventsOutsideAngular", ""]], inputs: { events: ["kendoEventsOutsideAngular", "events"], scope: "scope" } });
/** @nocollapse */
EventsOutsideAngularDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
EventsOutsideAngularDirective.propDecorators = {
    events: [{ type: Input, args: ['kendoEventsOutsideAngular',] }],
    scope: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventsOutsideAngularDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoEventsOutsideAngular]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { events: [{
            type: Input,
            args: ['kendoEventsOutsideAngular']
        }], scope: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class EventsModule {
}
EventsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EventsModule });
EventsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function EventsModule_Factory(t) { return new (t || EventsModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EventsModule, { declarations: [EventsOutsideAngularDirective], exports: [EventsOutsideAngularDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventsModule, [{
        type: NgModule,
        args: [{
                declarations: [EventsOutsideAngularDirective],
                exports: [EventsOutsideAngularDirective]
            }]
    }], null, null); })();

class ResizeService {
    constructor(resizeBatchService) {
        this.resizeBatchService = resizeBatchService;
        this.resize = new EventEmitter();
        this.acceptedSize = false;
        this.state = 0 /* Initial */;
    }
    acceptSize(size = this.measure()) {
        this.lastWidth = size.width;
        this.lastHeight = size.height;
        this.acceptedSize = true;
    }
    checkChanges() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.state === 0 /* Initial */) {
            this.state = 1 /* Initializing */;
            // batch initial measure
            this.resizeBatchService.schedule(this, this.init);
        }
    }
    destroy() {
        this.resizeBatchService.cancel(this);
    }
    checkSize() {
        if (!this.parentElement) {
            return;
        }
        const { width, height } = this.measure();
        const sameSize = width === this.lastWidth && height === this.lastHeight;
        if (sameSize) {
            return;
        }
        this.lastWidth = width;
        this.lastHeight = height;
        this.acceptedSize = false;
        this.resize.emit();
        return true;
    }
    initSize() {
        const size = this.measure();
        this.lastWidth = size.width;
        this.lastHeight = size.height;
    }
    measure() {
        let width = 0;
        let height = 0;
        if (this.parentElement) {
            height = this.parentElement.offsetHeight;
            width = this.parentElement.offsetWidth;
        }
        return { height, width };
    }
}

// tslint:disable:deprecation
const div = style => {
    const el = document.createElement('div');
    el.style.cssText = style;
    return el;
};
const computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);
const WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' +
    'overflow: hidden; visibility: hidden;';
const EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';
const SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';
class ResizeCompatService extends ResizeService {
    constructor(resizeBatchService, element, ngZone) {
        super(resizeBatchService);
        this.element = element;
        this.ngZone = ngZone;
    }
    checkChanges() {
        if (this.state === 2 /* Initialized */) {
            if (!this.resizeBatchService.isScheduled(this)) {
                this.resizeBatchService.schedule(this, this.checkSize);
            }
            return;
        }
        super.checkChanges();
    }
    destroy() {
        super.destroy();
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.expand) {
            const element = this.element.nativeElement;
            element.removeChild(this.expand);
            element.removeChild(this.shrink);
            this.expand.removeChild(this.expandChild);
            this.expand = this.expandChild = this.shrink = this.element = null;
        }
    }
    checkSize() {
        if (super.checkSize()) {
            this.reset();
            return true;
        }
    }
    init() {
        const parentElement = this.parentElement = this.element.nativeElement.parentElement;
        if (computedProp(parentElement, 'position') === 'static') {
            parentElement.style.position = 'relative';
        }
        this.state = 2 /* Initialized */;
        this.render();
        this.reset();
        this.initSize();
        this.subscribe();
    }
    render() {
        const element = this.element.nativeElement;
        element.style.cssText = WRAP_STYLE;
        element.setAttribute('dir', 'ltr');
        this.expand = div(WRAP_STYLE);
        this.expandChild = div(EXPAND_CHILD_STYLE);
        this.expand.appendChild(this.expandChild);
        element.appendChild(this.expand);
        this.shrink = div(WRAP_STYLE);
        const shrinkChild = div(SHRINK_CHILD_STYLE);
        this.shrink.appendChild(shrinkChild);
        element.appendChild(this.shrink);
    }
    reset() {
        const expandChild = this.expandChild;
        expandChild.style.width = 100000 + 'px';
        expandChild.style.height = 100000 + 'px';
        const expand = this.expand;
        expand.scrollLeft = 100000;
        expand.scrollTop = 100000;
        const shrink = this.shrink;
        shrink.scrollLeft = 100000;
        shrink.scrollTop = 100000;
    }
    subscribe() {
        this.ngZone.runOutsideAngular(() => {
            this.subscription = merge(fromEvent(this.shrink, 'scroll'), fromEvent(this.expand, 'scroll'))
                .subscribe(() => {
                this.checkSize();
            });
        });
    }
}

const HAS_OBSERVER = typeof ResizeObserver !== 'undefined';
/**
 * @hidden
 */
class ResizeObserverService extends ResizeService {
    constructor(resizeBatchService, element, ngZone) {
        super(resizeBatchService);
        this.element = element;
        this.ngZone = ngZone;
    }
    static supported() {
        return HAS_OBSERVER;
    }
    destroy() {
        super.destroy();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        this.parentElement = null;
    }
    init() {
        this.parentElement = this.element.nativeElement.parentElement;
        this.initSize();
        this.state = 2 /* Initialized */;
        this.ngZone.runOutsideAngular(() => {
            this.resizeObserver = new ResizeObserver(() => {
                this.checkSize();
            });
            this.resizeObserver.observe(this.parentElement);
        });
    }
}

/* tslint:disable:align */
/**
 * @hidden
 */
class ResizeBatchService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.scheduled = [];
        this.resolvedPromise = Promise.resolve(null);
        this.flush = this.flush.bind(this);
    }
    schedule(instance, method) {
        this.scheduled.push({ instance, method });
        if (!this.subscription) {
            this.ngZone.runOutsideAngular(() => {
                this.subscription = from(this.resolvedPromise)
                    .subscribe(this.flush);
            });
        }
    }
    isScheduled(instance) {
        return Boolean(this.scheduled.find(item => item.instance === instance));
    }
    cancel(instance) {
        const scheduled = this.scheduled;
        const count = scheduled.length;
        for (let idx = 0; idx < count; idx++) {
            if (scheduled[idx].instance === instance) {
                scheduled.splice(idx, 1);
                if (!scheduled.length) {
                    this.unsubscribe();
                }
                return;
            }
        }
    }
    ngOnDestroy() {
        this.unsubscribe();
    }
    unsubscribe() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    flush() {
        this.scheduled.forEach(item => {
            item.method.call(item.instance);
        });
        this.scheduled = [];
        this.unsubscribe();
    }
}
ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) { return new (t || ResizeBatchService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ResizeBatchService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ResizeBatchService, factory: ResizeBatchService.ɵfac });
/** @nocollapse */
ResizeBatchService.ctorParameters = () => [
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeBatchService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();

/**
 * Emit up to 10 resize events per second by default.
 * Chosen as a compromise between responsiveness and performance.
 */
const DEFAULT_RATE_LIMIT = 10;
/**
 * Resize Sensor Component
 *
 * Triggers a "resize" event whenever the parent DOM element size changes.
 */
class ResizeSensorComponent {
    constructor(resizeBatchService, element, ngZone) {
        /**
         * The maximum number of resize events to emit per second.
         *
         * Defaults to 10.
         */
        this.rateLimit = DEFAULT_RATE_LIMIT;
        /**
         * Fires when the parent DOM element has been resized.
         */
        this.resize = new EventEmitter();
        const serviceType = ResizeObserverService.supported() ? ResizeObserverService : ResizeCompatService;
        this.resizeService = new serviceType(resizeBatchService, element, ngZone);
        const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);
        this.subscription = this.resizeService.resize
            .pipe(auditTime(throttleTime))
            .subscribe(() => {
            if (!this.resizeService.acceptedSize) {
                this.resize.emit();
            }
        });
    }
    ngAfterViewChecked() {
        this.resizeService.checkChanges();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
        this.resizeService.destroy();
    }
    acceptSize(size) {
        this.resizeService.acceptSize(size);
    }
}
ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) { return new (t || ResizeSensorComponent)(ɵngcc0.ɵɵdirectiveInject(ResizeBatchService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ResizeSensorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ResizeSensorComponent, selectors: [["kendo-resize-sensor"]], inputs: { rateLimit: "rateLimit" }, outputs: { resize: "resize" }, decls: 0, vars: 0, template: function ResizeSensorComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ResizeSensorComponent.ctorParameters = () => [
    { type: ResizeBatchService },
    { type: ElementRef },
    { type: NgZone }
];
ResizeSensorComponent.propDecorators = {
    rateLimit: [{ type: Input }],
    resize: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeSensorComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-resize-sensor',
                template: ''
            }]
    }], function () { return [{ type: ResizeBatchService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { rateLimit: [{
            type: Input
        }], resize: [{
            type: Output
        }] }); })();

const COMPONENT_DIRECTIVES = [ResizeSensorComponent];
/**
 * Resize Sensor module
 */
class ResizeSensorModule {
}
ResizeSensorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ResizeSensorModule });
ResizeSensorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ResizeSensorModule_Factory(t) { return new (t || ResizeSensorModule)(); }, providers: [ResizeBatchService] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ResizeSensorModule, { declarations: [ResizeSensorComponent], exports: [ResizeSensorComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeSensorModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES],
                providers: [ResizeBatchService]
            }]
    }], null, null); })();

class KendoInput {
}

/**
 * Enum with key codes.
 */
var Keys;
(function (Keys) {
    Keys[Keys["Alt"] = 18] = "Alt";
    Keys[Keys["ArrowDown"] = 40] = "ArrowDown";
    Keys[Keys["ArrowLeft"] = 37] = "ArrowLeft";
    Keys[Keys["ArrowRight"] = 39] = "ArrowRight";
    Keys[Keys["ArrowUp"] = 38] = "ArrowUp";
    Keys[Keys["Backspace"] = 8] = "Backspace";
    Keys[Keys["Control"] = 17] = "Control";
    Keys[Keys["Delete"] = 46] = "Delete";
    Keys[Keys["Digit0"] = 48] = "Digit0";
    Keys[Keys["Digit1"] = 49] = "Digit1";
    Keys[Keys["Digit2"] = 50] = "Digit2";
    Keys[Keys["Digit3"] = 51] = "Digit3";
    Keys[Keys["Digit4"] = 52] = "Digit4";
    Keys[Keys["Digit5"] = 53] = "Digit5";
    Keys[Keys["Digit6"] = 54] = "Digit6";
    Keys[Keys["Digit7"] = 55] = "Digit7";
    Keys[Keys["Digit8"] = 56] = "Digit8";
    Keys[Keys["Digit9"] = 57] = "Digit9";
    Keys[Keys["End"] = 35] = "End";
    Keys[Keys["Enter"] = 13] = "Enter";
    Keys[Keys["Escape"] = 27] = "Escape";
    Keys[Keys["F1"] = 112] = "F1";
    Keys[Keys["F2"] = 113] = "F2";
    Keys[Keys["F10"] = 121] = "F10";
    Keys[Keys["Home"] = 36] = "Home";
    Keys[Keys["Insert"] = 45] = "Insert";
    Keys[Keys["KeyA"] = 65] = "KeyA";
    Keys[Keys["KeyB"] = 66] = "KeyB";
    Keys[Keys["KeyC"] = 67] = "KeyC";
    Keys[Keys["KeyD"] = 68] = "KeyD";
    Keys[Keys["KeyE"] = 69] = "KeyE";
    Keys[Keys["KeyF"] = 70] = "KeyF";
    Keys[Keys["KeyG"] = 71] = "KeyG";
    Keys[Keys["KeyH"] = 72] = "KeyH";
    Keys[Keys["KeyI"] = 73] = "KeyI";
    Keys[Keys["KeyJ"] = 74] = "KeyJ";
    Keys[Keys["KeyK"] = 75] = "KeyK";
    Keys[Keys["KeyL"] = 76] = "KeyL";
    Keys[Keys["KeyM"] = 77] = "KeyM";
    Keys[Keys["KeyN"] = 78] = "KeyN";
    Keys[Keys["KeyO"] = 79] = "KeyO";
    Keys[Keys["KeyP"] = 80] = "KeyP";
    Keys[Keys["KeyQ"] = 81] = "KeyQ";
    Keys[Keys["KeyR"] = 82] = "KeyR";
    Keys[Keys["KeyS"] = 83] = "KeyS";
    Keys[Keys["KeyT"] = 84] = "KeyT";
    Keys[Keys["KeyU"] = 85] = "KeyU";
    Keys[Keys["KeyV"] = 86] = "KeyV";
    Keys[Keys["KeyW"] = 87] = "KeyW";
    Keys[Keys["KeyX"] = 88] = "KeyX";
    Keys[Keys["KeyY"] = 89] = "KeyY";
    Keys[Keys["KeyZ"] = 90] = "KeyZ";
    Keys[Keys["NumpadDecimal"] = 110] = "NumpadDecimal";
    Keys[Keys["PageDown"] = 34] = "PageDown";
    Keys[Keys["PageUp"] = 33] = "PageUp";
    Keys[Keys["Shift"] = 16] = "Shift";
    Keys[Keys["Space"] = 32] = "Space";
    Keys[Keys["Tab"] = 9] = "Tab";
})(Keys || (Keys = {}));

/**
 * Generated bundle index. Do not edit.
 */

export { ResizeService, DraggableDirective, DraggableModule, EventsOutsideAngularDirective, EventsModule, ResizeSensorComponent, ResizeBatchService, ResizeCompatService, ResizeObserverService, ResizeSensorModule, KendoInput, isDocumentAvailable, isChanged, anyChanged, hasObservers, guid, Keys };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1NBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3T0FLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0hBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O3VFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxU0FNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgTmdab25lLCBJbnB1dCwgT3V0cHV0LCBOZ01vZHVsZSwgUmVuZGVyZXIyLCBJbmplY3RhYmxlLCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnQHRlbGVyaWsva2VuZG8tZHJhZ2dhYmxlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBtZXJnZSwgZnJvbUV2ZW50LCBmcm9tIH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IGlzRG9jdW1lbnRBdmFpbGFibGUgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBpc0NoYW5nZWQgPSAocHJvcGVydHlOYW1lLCBjaGFuZ2VzLCBza2lwRmlyc3RDaGFuZ2UgPSB0cnVlKSA9PiAodHlwZW9mIGNoYW5nZXNbcHJvcGVydHlOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoIWNoYW5nZXNbcHJvcGVydHlOYW1lXS5pc0ZpcnN0Q2hhbmdlKCkgfHwgIXNraXBGaXJzdENoYW5nZSkgJiZcbiAgICBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0ucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlc1twcm9wZXJ0eU5hbWVdLmN1cnJlbnRWYWx1ZSk7XG5cbmNvbnN0IGFueUNoYW5nZWQgPSAocHJvcGVydHlOYW1lcywgY2hhbmdlcywgc2tpcEZpcnN0Q2hhbmdlID0gdHJ1ZSkgPT4gcHJvcGVydHlOYW1lcy5zb21lKG5hbWUgPT4gaXNDaGFuZ2VkKG5hbWUsIGNoYW5nZXMsIHNraXBGaXJzdENoYW5nZSkpO1xuXG5jb25zdCBoYXNPYnNlcnZlcnMgPSAoZW1pdHRlcikgPT4gZW1pdHRlciAmJiBlbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwO1xuXG5jb25zdCBndWlkID0gKCkgPT4ge1xuICAgIGxldCBpZCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICBpZiAoaSA9PT0gOCB8fCBpID09PSAxMiB8fCBpID09PSAxNiB8fCBpID09PSAyMCkge1xuICAgICAgICAgICAgaWQgKz0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgaWQgKz0gKGkgPT09IDEyID8gNCA6IChpID09PSAxNiA/IChyYW5kb20gJiAzIHwgOCkgOiByYW5kb20pKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG5cbmNsYXNzIERyYWdnYWJsZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmVuYWJsZURyYWcgPSB0cnVlO1xuICAgICAgICB0aGlzLmtlbmRvUHJlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMua2VuZG9EcmFnID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtlbmRvUmVsZWFzZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlRHJhZ2dhYmxlKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGlzQ2hhbmdlZCgnZW5hYmxlRHJhZycsIGNoYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZURyYWdnYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lEcmFnZ2FibGUoKTtcbiAgICB9XG4gICAgdG9nZ2xlRHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAoaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lEcmFnZ2FibGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnOiAoZSkgPT4gdGhpcy5rZW5kb0RyYWcubmV4dChlKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlc3M6IChlKSA9PiB0aGlzLmtlbmRvUHJlc3MubmV4dChlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZTogKGUpID0+IHRoaXMua2VuZG9SZWxlYXNlLm5leHQoZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLmRyYWdnYWJsZS5iaW5kVG8odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95RHJhZ2dhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkRyYWdnYWJsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhZ2dhYmxlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHJhZ2dhYmxlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5EcmFnZ2FibGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZW5hYmxlRHJhZzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAga2VuZG9QcmVzczogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGtlbmRvRHJhZzogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGtlbmRvUmVsZWFzZTogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRHJhZ2dhYmxlTW9kdWxlIHtcbn1cbkRyYWdnYWJsZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbRHJhZ2dhYmxlRGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbRHJhZ2dhYmxlRGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbnB1dC1yZW5hbWUgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQgfHwgIXRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHRoaXMuc2NvcGUgPyBldmVudHNbbmFtZV0uYmluZCh0aGlzLnNjb3BlKSA6IGV2ZW50c1tuYW1lXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpZHhdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZXZlbnRzOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyJyxdIH1dLFxuICAgIHNjb3BlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEV2ZW50c01vZHVsZSB7XG59XG5FdmVudHNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0V2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbmNsYXNzIFJlc2l6ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZSA9IHJlc2l6ZUJhdGNoU2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIEluaXRpYWwgKi87XG4gICAgfVxuICAgIGFjY2VwdFNpemUoc2l6ZSA9IHRoaXMubWVhc3VyZSgpKSB7XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAwIC8qIEluaXRpYWwgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIEluaXRpYWxpemluZyAqLztcbiAgICAgICAgICAgIC8vIGJhdGNoIGluaXRpYWwgbWVhc3VyZVxuICAgICAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2Uuc2NoZWR1bGUodGhpcywgdGhpcy5pbml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5jYW5jZWwodGhpcyk7XG4gICAgfVxuICAgIGNoZWNrU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICBjb25zdCBzYW1lU2l6ZSA9IHdpZHRoID09PSB0aGlzLmxhc3RXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMubGFzdEhlaWdodDtcbiAgICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbml0U2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGggfTtcbiAgICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlOmRlcHJlY2F0aW9uXG5jb25zdCBkaXYgPSBzdHlsZSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgcmV0dXJuIGVsO1xufTtcbmNvbnN0IGNvbXB1dGVkUHJvcCA9IChlbGVtLCBwcm9wKSA9PiBnZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG5jb25zdCBXUkFQX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogYmxvY2s7IGxlZnQ6IDA7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgei1pbmRleDogLTE7JyArXG4gICAgJ292ZXJmbG93OiBoaWRkZW47IHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuY29uc3QgRVhQQU5EX0NISUxEX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB0cmFuc2l0aW9uOiAwczsnO1xuY29uc3QgU0hSSU5LX0NISUxEX1NUWUxFID0gRVhQQU5EX0NISUxEX1NUWUxFICsgJ3dpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCU7JztcbmNsYXNzIFJlc2l6ZUNvbXBhdFNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBJbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5pc1NjaGVkdWxlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplQmF0Y2hTZXJ2aWNlLnNjaGVkdWxlKHRoaXMsIHRoaXMuY2hlY2tTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5jaGVja0NoYW5nZXMoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZXhwYW5kKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5zaHJpbmspO1xuICAgICAgICAgICAgdGhpcy5leHBhbmQucmVtb3ZlQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZCA9IHRoaXMuZXhwYW5kQ2hpbGQgPSB0aGlzLnNocmluayA9IHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTaXplKCkge1xuICAgICAgICBpZiAoc3VwZXIuY2hlY2tTaXplKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoY29tcHV0ZWRQcm9wKHBhcmVudEVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogSW5pdGlhbGl6ZWQgKi87XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5pbml0U2l6ZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gV1JBUF9TVFlMRTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RpcicsICdsdHInKTtcbiAgICAgICAgdGhpcy5leHBhbmQgPSBkaXYoV1JBUF9TVFlMRSk7XG4gICAgICAgIHRoaXMuZXhwYW5kQ2hpbGQgPSBkaXYoRVhQQU5EX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5leHBhbmQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmQpO1xuICAgICAgICB0aGlzLnNocmluayA9IGRpdihXUkFQX1NUWUxFKTtcbiAgICAgICAgY29uc3Qgc2hyaW5rQ2hpbGQgPSBkaXYoU0hSSU5LX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5zaHJpbmsuYXBwZW5kQ2hpbGQoc2hyaW5rQ2hpbGQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hyaW5rKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cGFuZENoaWxkID0gdGhpcy5leHBhbmRDaGlsZDtcbiAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBjb25zdCBleHBhbmQgPSB0aGlzLmV4cGFuZDtcbiAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgIGV4cGFuZC5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgIGNvbnN0IHNocmluayA9IHRoaXMuc2hyaW5rO1xuICAgICAgICBzaHJpbmsuc2Nyb2xsTGVmdCA9IDEwMDAwMDtcbiAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IDEwMDAwMDtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG1lcmdlKGZyb21FdmVudCh0aGlzLnNocmluaywgJ3Njcm9sbCcpLCBmcm9tRXZlbnQodGhpcy5leHBhbmQsICdzY3JvbGwnKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgSEFTX09CU0VSVkVSID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVPYnNlcnZlclNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIEhBU19PQlNFUlZFUjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmluaXRTaXplKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTphbGlnbiAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFJlc2l6ZUJhdGNoU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgdGhpcy5mbHVzaCA9IHRoaXMuZmx1c2guYmluZCh0aGlzKTtcbiAgICB9XG4gICAgc2NoZWR1bGUoaW5zdGFuY2UsIG1ldGhvZCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlZC5wdXNoKHsgaW5zdGFuY2UsIG1ldGhvZCB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gZnJvbSh0aGlzLnJlc29sdmVkUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmZsdXNoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzU2NoZWR1bGVkKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc2NoZWR1bGVkLmZpbmQoaXRlbSA9PiBpdGVtLmluc3RhbmNlID09PSBpbnN0YW5jZSkpO1xuICAgIH1cbiAgICBjYW5jZWwoaW5zdGFuY2UpIHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkID0gdGhpcy5zY2hlZHVsZWQ7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gc2NoZWR1bGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY291bnQ7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVkW2lkeF0uaW5zdGFuY2UgPT09IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmICghc2NoZWR1bGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5tZXRob2QuY2FsbChpdGVtLmluc3RhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gW107XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5SZXNpemVCYXRjaFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblJlc2l6ZUJhdGNoU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuXG4vKipcbiAqIEVtaXQgdXAgdG8gMTAgcmVzaXplIGV2ZW50cyBwZXIgc2Vjb25kIGJ5IGRlZmF1bHQuXG4gKiBDaG9zZW4gYXMgYSBjb21wcm9taXNlIGJldHdlZW4gcmVzcG9uc2l2ZW5lc3MgYW5kIHBlcmZvcm1hbmNlLlxuICovXG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVQgPSAxMDtcbi8qKlxuICogUmVzaXplIFNlbnNvciBDb21wb25lbnRcbiAqXG4gKiBUcmlnZ2VycyBhIFwicmVzaXplXCIgZXZlbnQgd2hlbmV2ZXIgdGhlIHBhcmVudCBET00gZWxlbWVudCBzaXplIGNoYW5nZXMuXG4gKi9cbmNsYXNzIFJlc2l6ZVNlbnNvckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocmVzaXplQmF0Y2hTZXJ2aWNlLCBlbGVtZW50LCBuZ1pvbmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXNpemUgZXZlbnRzIHRvIGVtaXQgcGVyIHNlY29uZC5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgdG8gMTAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhdGVMaW1pdCA9IERFRkFVTFRfUkFURV9MSU1JVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBhcmVudCBET00gZWxlbWVudCBoYXMgYmVlbiByZXNpemVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VUeXBlID0gUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlLnN1cHBvcnRlZCgpID8gUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlIDogUmVzaXplQ29tcGF0U2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlID0gbmV3IHNlcnZpY2VUeXBlKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKTtcbiAgICAgICAgY29uc3QgdGhyb3R0bGVUaW1lID0gMTAwMCAvICh0aGlzLnJhdGVMaW1pdCB8fCBERUZBVUxUX1JBVEVfTElNSVQpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMucmVzaXplU2VydmljZS5yZXNpemVcbiAgICAgICAgICAgIC5waXBlKGF1ZGl0VGltZSh0aHJvdHRsZVRpbWUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzaXplU2VydmljZS5hY2NlcHRlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZS5jaGVja0NoYW5nZXMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGFjY2VwdFNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuYWNjZXB0U2l6ZShzaXplKTtcbiAgICB9XG59XG5SZXNpemVTZW5zb3JDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXJlc2l6ZS1zZW5zb3InLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5SZXNpemVTZW5zb3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBSZXNpemVCYXRjaFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuUmVzaXplU2Vuc29yQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHJhdGVMaW1pdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmVzaXplOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbmNvbnN0IENPTVBPTkVOVF9ESVJFQ1RJVkVTID0gW1Jlc2l6ZVNlbnNvckNvbXBvbmVudF07XG4vKipcbiAqIFJlc2l6ZSBTZW5zb3IgbW9kdWxlXG4gKi9cbmNsYXNzIFJlc2l6ZVNlbnNvck1vZHVsZSB7XG59XG5SZXNpemVTZW5zb3JNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1Jlc2l6ZUJhdGNoU2VydmljZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuY2xhc3MgS2VuZG9JbnB1dCB7XG59XG5cbi8qKlxuICogRW51bSB3aXRoIGtleSBjb2Rlcy5cbiAqL1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93RG93blwiXSA9IDQwXSA9IFwiQXJyb3dEb3duXCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dMZWZ0XCJdID0gMzddID0gXCJBcnJvd0xlZnRcIjtcbiAgICBLZXlzW0tleXNbXCJBcnJvd1JpZ2h0XCJdID0gMzldID0gXCJBcnJvd1JpZ2h0XCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dVcFwiXSA9IDM4XSA9IFwiQXJyb3dVcFwiO1xuICAgIEtleXNbS2V5c1tcIkJhY2tzcGFjZVwiXSA9IDhdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJDb250cm9sXCJdID0gMTddID0gXCJDb250cm9sXCI7XG4gICAgS2V5c1tLZXlzW1wiRGVsZXRlXCJdID0gNDZdID0gXCJEZWxldGVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDBcIl0gPSA0OF0gPSBcIkRpZ2l0MFwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0MVwiXSA9IDQ5XSA9IFwiRGlnaXQxXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQyXCJdID0gNTBdID0gXCJEaWdpdDJcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDNcIl0gPSA1MV0gPSBcIkRpZ2l0M1wiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0NFwiXSA9IDUyXSA9IFwiRGlnaXQ0XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ1XCJdID0gNTNdID0gXCJEaWdpdDVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDZcIl0gPSA1NF0gPSBcIkRpZ2l0NlwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0N1wiXSA9IDU1XSA9IFwiRGlnaXQ3XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ4XCJdID0gNTZdID0gXCJEaWdpdDhcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDlcIl0gPSA1N10gPSBcIkRpZ2l0OVwiO1xuICAgIEtleXNbS2V5c1tcIkVuZFwiXSA9IDM1XSA9IFwiRW5kXCI7XG4gICAgS2V5c1tLZXlzW1wiRW50ZXJcIl0gPSAxM10gPSBcIkVudGVyXCI7XG4gICAgS2V5c1tLZXlzW1wiRXNjYXBlXCJdID0gMjddID0gXCJFc2NhcGVcIjtcbiAgICBLZXlzW0tleXNbXCJGMVwiXSA9IDExMl0gPSBcIkYxXCI7XG4gICAgS2V5c1tLZXlzW1wiRjJcIl0gPSAxMTNdID0gXCJGMlwiO1xuICAgIEtleXNbS2V5c1tcIkYxMFwiXSA9IDEyMV0gPSBcIkYxMFwiO1xuICAgIEtleXNbS2V5c1tcIkhvbWVcIl0gPSAzNl0gPSBcIkhvbWVcIjtcbiAgICBLZXlzW0tleXNbXCJJbnNlcnRcIl0gPSA0NV0gPSBcIkluc2VydFwiO1xuICAgIEtleXNbS2V5c1tcIktleUFcIl0gPSA2NV0gPSBcIktleUFcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlCXCJdID0gNjZdID0gXCJLZXlCXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5Q1wiXSA9IDY3XSA9IFwiS2V5Q1wiO1xuICAgIEtleXNbS2V5c1tcIktleURcIl0gPSA2OF0gPSBcIktleURcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlFXCJdID0gNjldID0gXCJLZXlFXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5RlwiXSA9IDcwXSA9IFwiS2V5RlwiO1xuICAgIEtleXNbS2V5c1tcIktleUdcIl0gPSA3MV0gPSBcIktleUdcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlIXCJdID0gNzJdID0gXCJLZXlIXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5SVwiXSA9IDczXSA9IFwiS2V5SVwiO1xuICAgIEtleXNbS2V5c1tcIktleUpcIl0gPSA3NF0gPSBcIktleUpcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlLXCJdID0gNzVdID0gXCJLZXlLXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5TFwiXSA9IDc2XSA9IFwiS2V5TFwiO1xuICAgIEtleXNbS2V5c1tcIktleU1cIl0gPSA3N10gPSBcIktleU1cIjtcbiAgICBLZXlzW0tleXNbXCJLZXlOXCJdID0gNzhdID0gXCJLZXlOXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5T1wiXSA9IDc5XSA9IFwiS2V5T1wiO1xuICAgIEtleXNbS2V5c1tcIktleVBcIl0gPSA4MF0gPSBcIktleVBcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlRXCJdID0gODFdID0gXCJLZXlRXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5UlwiXSA9IDgyXSA9IFwiS2V5UlwiO1xuICAgIEtleXNbS2V5c1tcIktleVNcIl0gPSA4M10gPSBcIktleVNcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlUXCJdID0gODRdID0gXCJLZXlUXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5VVwiXSA9IDg1XSA9IFwiS2V5VVwiO1xuICAgIEtleXNbS2V5c1tcIktleVZcIl0gPSA4Nl0gPSBcIktleVZcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlXXCJdID0gODddID0gXCJLZXlXXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5WFwiXSA9IDg4XSA9IFwiS2V5WFwiO1xuICAgIEtleXNbS2V5c1tcIktleVlcIl0gPSA4OV0gPSBcIktleVlcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlaXCJdID0gOTBdID0gXCJLZXlaXCI7XG4gICAgS2V5c1tLZXlzW1wiTnVtcGFkRGVjaW1hbFwiXSA9IDExMF0gPSBcIk51bXBhZERlY2ltYWxcIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlRG93blwiXSA9IDM0XSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlVXBcIl0gPSAzM10gPSBcIlBhZ2VVcFwiO1xuICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xuICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgIEtleXNbS2V5c1tcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IFJlc2l6ZVNlcnZpY2UsIERyYWdnYWJsZURpcmVjdGl2ZSwgRHJhZ2dhYmxlTW9kdWxlLCBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZSwgRXZlbnRzTW9kdWxlLCBSZXNpemVTZW5zb3JDb21wb25lbnQsIFJlc2l6ZUJhdGNoU2VydmljZSwgUmVzaXplQ29tcGF0U2VydmljZSwgUmVzaXplT2JzZXJ2ZXJTZXJ2aWNlLCBSZXNpemVTZW5zb3JNb2R1bGUsIEtlbmRvSW5wdXQsIGlzRG9jdW1lbnRBdmFpbGFibGUsIGlzQ2hhbmdlZCwgYW55Q2hhbmdlZCwgaGFzT2JzZXJ2ZXJzLCBndWlkLCBLZXlzIH07XG4iXX0=