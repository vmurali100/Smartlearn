/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable, InjectionToken, Inject, Optional, NgZone, EventEmitter, isDevMode, Component, ElementRef, Renderer2, Input, Output, ViewChild, TemplateRef, ApplicationRef, ComponentFactoryResolver, Injector, NgModule } from '@angular/core';
import { siblingContainer, parents, addScroll, align, boundingOffset, offset, positionWithScroll, removeScroll, restrictToView, scrollPosition, getWindowViewPort } from '@progress/kendo-popup-common';
import { isDocumentAvailable, hasObservers, ResizeSensorComponent, ResizeSensorModule } from '@progress/kendo-angular-common';
import { fromEvent, merge, from } from 'rxjs';
import { auditTime } from 'rxjs/operators';
import { style, animate, AnimationBuilder } from '@angular/animations';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@progress/kendo-angular-common';

const _c0 = ["container"];
function PopupComponent_ng_template_3_Template(rf, ctx) { }
const _c1 = ["*"];
const eitherRect = (rect, offset$$1) => {
    if (!rect) {
        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };
    }
    return rect;
};
/**
 * @hidden
 */
const removeStackingOffset = (rect, stackingOffset) => {
    if (!stackingOffset) {
        return rect;
    }
    const result = {
        height: rect.height,
        left: rect.left - stackingOffset.left,
        top: rect.top - stackingOffset.top,
        width: rect.width
    };
    return result;
};
/**
 * @hidden
 */
const isDifferentOffset = (oldOffset, newOffset) => {
    const { left: oldLeft, top: oldTop } = oldOffset;
    const { left: newLeft, top: newTop } = newOffset;
    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;
};
/**
 * @hidden
 */
const isWindowAvailable = () => {
    return typeof window !== 'undefined';
};
/**
 * @hidden
 */
const OVERFLOW_REGEXP = /auto|scroll/;
const overflowElementStyle = (element) => {
    return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;
};
const overflowComputedStyle = (element) => {
    const styles = window.getComputedStyle(element);
    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;
};
const overflowStyle = (element) => {
    return overflowElementStyle(element) || overflowComputedStyle(element);
};
/**
 * @hidden
 */
const scrollableParents = (element) => {
    const parentElements = [];
    if (!isDocumentAvailable() || !isWindowAvailable()) {
        return parentElements;
    }
    let parent = element.parentElement;
    while (parent) {
        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {
            parentElements.push(parent);
        }
        parent = parent.parentElement;
    }
    parentElements.push(window);
    return parentElements;
};
/**
 * @hidden
 */
const FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps
function memoize(fun) {
    let result;
    let called = false;
    return (...args) => {
        if (called) {
            return result;
        }
        result = fun(...args);
        called = true;
        return result;
    };
}
/**
 * @hidden
 */
const hasRelativeStackingContext = memoize(() => {
    if (!isDocumentAvailable() && document.body !== null) {
        return false;
    }
    const top = 10;
    const parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = `<div style="position: fixed; top: ${top}px;">child</div>`;
    document.body.appendChild(parent);
    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
});
/**
 * @hidden
 */
const zIndex = (anchor, container) => {
    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {
        return null;
    }
    const sibling = siblingContainer(anchor, container);
    if (!sibling) {
        return null;
    }
    const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {
        const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;
        const current = parseInt(zIndexStyle, 10);
        return current > index ? current : index;
    }, 0);
    return result ? (result + 1) : null;
};
/**
 * @hidden
 */
const scaleRect = (rect, scale) => {
    if (!rect || scale === 1) {
        return rect;
    }
    return {
        height: rect.height / scale,
        left: rect.left / scale,
        top: rect.top / scale,
        width: rect.width / scale
    };
};

const STYLES = [
    'font-size',
    'font-family',
    'font-stretch',
    'font-style',
    'font-weight',
    'line-height'
];
/**
 * @hidden
 */
class DOMService {
    addOffset(current, addition) {
        return {
            left: current.left + addition.left,
            top: current.top + addition.top
        };
    }
    addScroll(rect, scroll) {
        return addScroll(rect, scroll);
    }
    align(settings) {
        return align(settings);
    }
    boundingOffset(el) {
        return boundingOffset(this.nativeElement(el));
    }
    getFontStyles(el) {
        const window = this.getWindow();
        if (!window || !el) {
            return [];
        }
        const computedStyles = window.getComputedStyle(this.nativeElement(el));
        return STYLES.map(font => ({ key: font, value: computedStyles[font] }));
    }
    getWindow() {
        return isWindowAvailable() ? window : null;
    }
    hasOffsetParent(el) {
        if (!el) {
            return false;
        }
        return !!this.nativeElement(el).offsetParent;
    }
    offset(el) {
        if (!el) {
            return null;
        }
        return offset(this.nativeElement(el));
    }
    offsetAtPoint(el, currentLocation) {
        if (!el) {
            return null;
        }
        const element = this.nativeElement(el);
        const { left, top, transition } = element.style;
        element.style.transition = 'none';
        element.style.left = `${currentLocation.left}px`;
        element.style.top = `${currentLocation.top}px`;
        const currentOffset = offset(element);
        element.style.left = left;
        element.style.top = top;
        // prevents elements with transition to be animated because of the change
        // tslint:disable-next-line:no-unused-expression
        element.offsetHeight;
        element.style.transition = transition;
        return currentOffset;
    }
    nativeElement(el) {
        if (!el) {
            return null;
        }
        return el.nativeElement || el;
    }
    position(element, popup, scale = 1) {
        if (!element || !popup) {
            return null;
        }
        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);
    }
    removeScroll(rect, scroll) {
        return removeScroll(rect, scroll);
    }
    restrictToView(settings) {
        return restrictToView(settings);
    }
    scrollPosition(el) {
        return scrollPosition(this.nativeElement(el));
    }
    scrollableParents(el) {
        return scrollableParents(this.nativeElement(el));
    }
    stackingElementOffset(el) {
        const relativeContextElement = this.getRelativeContextElement(el);
        if (!relativeContextElement) {
            return null;
        }
        return offset(relativeContextElement);
    }
    stackingElementScroll(el) {
        const relativeContextElement = this.getRelativeContextElement(el);
        if (!relativeContextElement) {
            return { x: 0, y: 0 };
        }
        return {
            x: relativeContextElement.scrollLeft,
            y: relativeContextElement.scrollTop
        };
    }
    getRelativeContextElement(el) {
        if (!el || !hasRelativeStackingContext()) {
            return null;
        }
        let parent = this.nativeElement(el).parentElement;
        while (parent) {
            if (window.getComputedStyle(parent).transform !== 'none') {
                return parent;
            }
            parent = parent.parentElement;
        }
        return null;
    }
    useRelativePosition(el) {
        return !!this.getRelativeContextElement(el);
    }
    windowViewPort(el) {
        return getWindowViewPort(this.nativeElement(el));
    }
    zIndex(anchor, container) {
        return zIndex(this.nativeElement(anchor), this.nativeElement(container));
    }
    zoomLevel() {
        if (!isDocumentAvailable() || !isWindowAvailable()) {
            return 1;
        }
        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;
    }
    isZoomed() {
        return this.zoomLevel() > 1;
    }
}
DOMService.ɵfac = function DOMService_Factory(t) { return new (t || DOMService)(); };
DOMService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DOMService, factory: DOMService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DOMService, [{
        type: Injectable
    }], null, null); })();

/**
 * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).
 *
 * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).
 *
 * > Using this token is not necessary for user-applied browser zoom.
 *
 * {% meta height:300 %}
 * {% embed_file scale/app.component.ts preview %}
 * {% embed_file scale/app.module.ts %}
 * {% embed_file scale/main.ts %}
 * {% endmeta %}
 *
 *
 */
const SCALE = new InjectionToken('Popup Document Scale');

/**
 * @hidden
 */
class AlignService {
    constructor(_dom, scale = 1) {
        this._dom = _dom;
        this.scale = scale;
    }
    alignElement(settings) {
        const { anchor, element, anchorAlign, elementAlign, margin, offset: offset$$1, positionMode } = settings;
        const scale = this.scale || 1;
        const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);
        const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);
        const elementRect = scaleRect(this._dom.offset(element), scale);
        const result = this._dom.align({
            anchorAlign: anchorAlign,
            anchorRect: anchorRect,
            elementAlign: elementAlign,
            elementRect: elementRect,
            margin
        });
        return result;
    }
    absoluteRect(anchor, element, offset$$1, scale) {
        const scrollPos = this.elementScrollPosition(anchor, element);
        const rect = eitherRect(this._dom.offset(anchor), offset$$1);
        const stackScale = 2 * scale;
        const stackScroll = this._dom.stackingElementScroll(element);
        if (scale !== 1 && stackScroll) {
            stackScroll.x /= stackScale;
            stackScroll.y /= stackScale;
        }
        const stackOffset = this._dom.stackingElementOffset(element);
        if (scale !== 1 && stackOffset) {
            stackOffset.left /= stackScale;
            stackOffset.top /= stackScale;
        }
        return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);
    }
    elementScrollPosition(anchor, element) {
        return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);
    }
    relativeRect(anchor, element, offset$$1, scale) {
        const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);
        return scaleRect(rect, scale);
    }
}
AlignService.ɵfac = function AlignService_Factory(t) { return new (t || AlignService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8)); };
AlignService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AlignService, factory: AlignService.ɵfac });
/** @nocollapse */
AlignService.ctorParameters = () => [
    { type: DOMService },
    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AlignService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: Number, decorators: [{
                type: Inject,
                args: [SCALE]
            }, {
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class PositionService {
    constructor(_dom, scale = 1) {
        this._dom = _dom;
        this.scale = scale;
    }
    positionElement(settings) {
        const { anchor, currentLocation, element, anchorAlign, elementAlign, collisions, margin } = settings;
        const dom = this._dom;
        const scale = this.scale || 1;
        const elementOffset = dom.offsetAtPoint(element, currentLocation);
        const elementRect = scaleRect(elementOffset, scale);
        const anchorOffset = scaleRect(dom.offset(anchor), scale);
        const anchorRect = eitherRect(anchorOffset, currentLocation);
        const viewPort = settings.viewPort || dom.windowViewPort(element);
        viewPort.width = viewPort.width / scale;
        viewPort.height = viewPort.height / scale;
        const result = dom.restrictToView({
            anchorAlign,
            anchorRect,
            collisions,
            elementAlign,
            elementRect,
            margin,
            viewPort
        });
        const offset$$1 = dom.addOffset(currentLocation, result.offset);
        return {
            flip: result.flip,
            flipped: result.flipped,
            offset: offset$$1
        };
    }
}
PositionService.ɵfac = function PositionService_Factory(t) { return new (t || PositionService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(SCALE, 8)); };
PositionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PositionService, factory: PositionService.ɵfac });
/** @nocollapse */
PositionService.ctorParameters = () => [
    { type: DOMService },
    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PositionService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: Number, decorators: [{
                type: Inject,
                args: [SCALE]
            }, {
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class ResizeService {
    constructor(_dom, _zone) {
        this._dom = _dom;
        this._zone = _zone;
    }
    subscribe(callback) {
        if (!isDocumentAvailable()) {
            return;
        }
        this._zone.runOutsideAngular(() => {
            this.subscription = fromEvent(this._dom.getWindow(), "resize")
                .pipe(auditTime(FRAME_DURATION))
                .subscribe(() => callback());
        });
    }
    unsubscribe() {
        if (!this.subscription) {
            return;
        }
        this.subscription.unsubscribe();
    }
    isUnsubscribed() {
        return this.subscription && this.subscription.closed;
    }
}
ResizeService.ɵfac = function ResizeService_Factory(t) { return new (t || ResizeService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ResizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ResizeService, factory: ResizeService.ɵfac });
/** @nocollapse */
ResizeService.ctorParameters = () => [
    { type: DOMService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizeService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: ɵngcc0.NgZone }]; }, null); })();

/**
 * @hidden
 */
const THRESHOLD_DIFF = 1;
/**
 * @hidden
 */
class ScrollableService {
    constructor(_dom, _zone) {
        this._dom = _dom;
        this._zone = _zone;
    }
    forElement(element) {
        this.unsubscribe();
        this.element = element;
        return this;
    }
    subscribe(callback) {
        if (!callback || !isDocumentAvailable() || !this.element) {
            return;
        }
        const nativeElement = this._dom.nativeElement(this.element);
        const parents$$1 = this._dom.scrollableParents(this.element);
        this._zone.runOutsideAngular(() => {
            const observables = parents$$1.map(p => fromEvent(p, "scroll").pipe(auditTime(FRAME_DURATION)));
            const subscriber = (e) => {
                const target = e.target;
                const isParent = parents$$1.filter(p => p === target).length > 0;
                const isDocument = target === document;
                const isWindow = target === window;
                if (isParent || isDocument || isWindow) {
                    callback(this.isVisible(nativeElement, target));
                }
            };
            this.subscription = merge(...observables).subscribe(subscriber);
        });
    }
    unsubscribe() {
        if (!this.subscription) {
            return;
        }
        this.subscription.unsubscribe();
    }
    isVisible(elem, container) {
        const elemRect = this._dom.boundingOffset(elem);
        const containerRect = this._dom.boundingOffset(container);
        if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {
            return false;
        }
        if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {
            return false;
        }
        if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {
            return false;
        }
        if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {
            return false;
        }
        return true;
    }
}
ScrollableService.ɵfac = function ScrollableService_Factory(t) { return new (t || ScrollableService)(ɵngcc0.ɵɵinject(DOMService), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ScrollableService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScrollableService, factory: ScrollableService.ɵfac });
/** @nocollapse */
ScrollableService.ctorParameters = () => [
    { type: DOMService },
    { type: NgZone }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScrollableService, [{
        type: Injectable
    }], function () { return [{ type: DOMService }, { type: ɵngcc0.NgZone }]; }, null); })();

const LEFT = 'left';
const RIGHT = 'right';
const DOWN = 'down';
const UP = 'up';
const DEFAULT_TYPE = 'slide';
const DEFAULT_DURATION = 100;
const animationTypes = {};
/* tslint:disable:object-literal-sort-keys */
animationTypes.expand = (direction) => {
    const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';
    const startScale = 0;
    const endScale = 1;
    let origin;
    if (direction === DOWN) {
        origin = 'top';
    }
    else if (direction === LEFT) {
        origin = RIGHT;
    }
    else if (direction === RIGHT) {
        origin = LEFT;
    }
    else {
        origin = 'bottom';
    }
    return {
        start: { transform: `${scale}(${startScale})`, transformOrigin: origin },
        end: { transform: `${scale}(${endScale})` }
    };
};
animationTypes.slide = (direction) => {
    const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';
    const start = direction === RIGHT || direction === DOWN ? -100 : 100;
    const end = 0;
    return {
        start: { transform: `${translate}(${start}%)` },
        end: { transform: `${translate}(${end}%)` }
    };
};
animationTypes.fade = () => {
    return {
        start: { opacity: 0 },
        end: { opacity: 1 }
    };
};
animationTypes.zoom = () => {
    const start = 0;
    const end = 1;
    return {
        start: { transform: `scale(${start})` },
        end: { transform: `scale(${end})` }
    };
};
/**
 * @hidden
 */
class AnimationService {
    constructor(animationBuilder) {
        this.animationBuilder = animationBuilder;
        this.start = new EventEmitter();
        this.end = new EventEmitter();
    }
    play(element, options, flip) {
        if (!this.flip || this.flip.horizontal !== flip.horizontal ||
            this.flip.vertical !== flip.vertical) {
            this.flip = flip;
            const type = options.type || DEFAULT_TYPE;
            const statesFn = animationTypes[type];
            if (statesFn) {
                const direction = this.getDirection(flip, options);
                const states = statesFn(direction);
                this.playStates(element, states, options);
            }
            else if (isDevMode()) {
                throw new Error(`Unsupported animation type: "${type}". The supported types are slide, expand, fade and zoom.`);
            }
        }
    }
    ngOnDestroy() {
        this.stopPlayer();
    }
    playStates(element, states, options) {
        this.stopPlayer();
        const duration = options.duration || DEFAULT_DURATION;
        const factory = this.animationBuilder.build([
            style(states.start),
            animate(`${duration}ms ease-in`, style(states.end))
        ]);
        const player = this.player = factory.create(element);
        player.onDone(() => {
            this.end.emit();
            this.stopPlayer();
        });
        this.start.emit();
        player.play();
    }
    getDirection(flip, options) {
        let direction = options.direction || DOWN;
        if (flip.horizontal) {
            if (direction === LEFT) {
                direction = RIGHT;
            }
            else if (direction === RIGHT) {
                direction = LEFT;
            }
        }
        if (flip.vertical) {
            if (direction === DOWN) {
                direction = UP;
            }
            else if (direction === UP) {
                direction = DOWN;
            }
        }
        return direction;
    }
    stopPlayer() {
        if (this.player) {
            this.player.destroy();
            this.player = null;
        }
    }
}
AnimationService.ɵfac = function AnimationService_Factory(t) { return new (t || AnimationService)(ɵngcc0.ɵɵinject(ɵngcc1.AnimationBuilder)); };
AnimationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AnimationService, factory: AnimationService.ɵfac });
/** @nocollapse */
AnimationService.ctorParameters = () => [
    { type: AnimationBuilder }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AnimationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }]; }, null); })();

const DEFAULT_OFFSET = { left: -10000, top: 0 };
const ANIMATION_CONTAINER = 'k-animation-container';
const ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';
/**
 * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <button #anchor (click)="show=!show">Toggle</button>
 *  <kendo-popup *ngIf="show" [anchor]="anchor">
 *      <strong>Popup content!</strong>
 *  </kendo-popup>
 * `
 * })
 * class AppComponent {
 *   public show: boolean = false;
 * }
 * ```
 */
class PopupComponent {
    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {
        this.container = container;
        this._alignService = _alignService;
        this.domService = domService;
        this._positionService = _positionService;
        this._resizeService = _resizeService;
        this._scrollableService = _scrollableService;
        this.animationService = animationService;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Controls the Popup animation. By default, the opening and closing animations
         * are enabled ([see example]({% slug animations_popup %})).
         */
        this.animate = true;
        /**
         * Specifies the anchor pivot point
         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).
         */
        this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };
        /**
         * Configures the collision behavior of the Popup
         * ([see example]({% slug viewportboundarydetection_popup %})).
         */
        this.collision = { horizontal: 'fit', vertical: 'flip' };
        /**
         * Specifies the pivot point of the Popup
         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).
         */
        this.popupAlign = { horizontal: 'left', vertical: 'top' };
        /**
         * Controls whether the component will copy the `anchor` font styles.
         */
        this.copyAnchorStyles = false;
        /**
         * Specifies the position mode of the component. By default, the Popup uses fixed positioning.
         * To make the Popup acquire absolute positioning, set this option to `absolute`.
         *
         * > If you need to support mobile browsers with the zoom option,
         * use the `absolute` positioning of the Popup.
         *
         * @example
         * ```html
         * <style>
         *  .parent-content {
         *     position: relative;
         *     width: 200px;
         *     height: 200px;
         *     overflow: auto;
         *     margin: 200px auto;
         *     border: 1px solid red;
         *  }
         *  .content {
         *     position: relative;
         *     width: 100px;
         *     height: 100px;
         *     overflow: auto;
         *     margin: 300px;
         *     border: 1px solid blue;
         *  }
         *  .anchor {
         *     position: absolute;
         *     top: 200px;
         *     left: 200px;
         *  }
         * </style>
         * ```
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <div class="example-config">
         *      Position mode:
         *      <label><input type="radio" value="fixed" [(ngModel)]="mode" /> Fixed</label>
         *      <label><input type="radio" value="absolute" [(ngModel)]="mode" /> Absolute</label>
         *   </div>
         *   <div class="example-config">
         *       Append to
         *       <label>
         *           <input type="radio" name="place" [value]="1" [(ngModel)]="checked" />
         *           Root component
         *       </label>
         *       <label>
         *           <input type="radio" name="place" [value]="2" [(ngModel)]="checked" />
         *           <span style="color: red">Red Container</span>
         *       </label>
         *       <label>
         *           <input type="radio" name="place" [value]="3" [(ngModel)]="checked" />
         *           <span style="color: blue">Blue Container</span>
         *       </label>
         *   </div>
         *   <div class="example">
         *     <div class="parent-content" [scrollLeft]="250" [scrollTop]="230">
         *         <div class="content" [scrollLeft]="170" [scrollTop]="165">
         *           <button #anchor class="anchor" (click)="show = !show">Toggle</button>
         *           <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 3">
         *             <ul>
         *                 <li>Item1</li>
         *                 <li>Item2</li>
         *                 <li>Item3</li>
         *             </ul>
         *           </kendo-popup>
         *           <span style="position: absolute; top: 400px; left: 400px">Bottom/Right</span>
         *         </div>
         *         <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 2">
         *           <ul>
         *               <li>Item1</li>
         *               <li>Item2</li>
         *               <li>Item3</li>
         *           </ul>
         *         </kendo-popup>
         *         <span style="position: absolute; top: 600px; left: 600px">Bottom/Right</span>
         *     </div>
         *     <kendo-popup [positionMode]="mode" [anchor]="anchor" (anchorViewportLeave)="show=false" *ngIf="show && checked === 1">
         *       <ul>
         *           <li>Item1</li>
         *           <li>Item2</li>
         *           <li>Item3</li>
         *       </ul>
         *     </kendo-popup>
         *   </div>
         * `
         * })
         * class AppComponent {
         *   public checked: number = 3;
         *   public mode: string = 'absolute';
         *   public show: boolean = true;
         * }
         * ```
         */
        this.positionMode = 'fixed';
        /**
         * Specifies the absolute position of the element
         * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).
         * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.
         * The boundary detection is applied by using the window viewport.
         */
        this.offset = DEFAULT_OFFSET;
        /**
         * Fires when the anchor is scrolled outside the screen boundaries.
         * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).
         */
        this.anchorViewportLeave = new EventEmitter();
        /**
         * Fires after the component is closed.
         */
        this.close = new EventEmitter();
        /**
         * Fires after the component is opened and the opening animation ends.
         */
        this.open = new EventEmitter();
        /**
         * Fires after the component is opened and the Popup is positioned.
         */
        this.positionChange = new EventEmitter();
        this.resolvedPromise = Promise.resolve(null);
        this.initialCheck = true;
        this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);
        this.updateFixedClass();
    }
    ngOnInit() {
        this.reposition = this.reposition.bind(this);
        this._resizeService.subscribe(this.reposition);
        this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));
        this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));
        this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));
        this.currentOffset = DEFAULT_OFFSET;
        this.setZIndex();
        this.copyFontStyles();
        this.updateFixedClass();
    }
    ngOnChanges(changes) {
        if (changes.copyAnchorStyles) {
            this.copyFontStyles();
        }
        if (changes.positionMode) {
            this.updateFixedClass();
        }
    }
    ngAfterViewInit() {
        this.reposition();
        if (!this.animate) {
            this.resolvedPromise.then(() => {
                this.onAnimationEnd();
            });
        }
    }
    ngAfterViewChecked() {
        if (this.initialCheck) {
            this.initialCheck = false;
            return;
        }
        this._zone.runOutsideAngular(() => {
            // workarounds https://github.com/angular/angular/issues/19094
            // uses promise because it is executed synchronously after the content is updated
            // does not use onStable in case the current zone is not the angular one.
            this.unsubscribeReposition();
            this.repositionSubscription = from(this.resolvedPromise)
                .subscribe(this.reposition);
        });
    }
    ngOnDestroy() {
        this.anchorViewportLeave.complete();
        this.positionChange.complete();
        this.close.emit();
        this.close.complete();
        this._resizeService.unsubscribe();
        this._scrollableService.unsubscribe();
        this.animationSubscriptions.unsubscribe();
        this.unsubscribeReposition();
    }
    /**
     * @hidden
     */
    onResize() {
        this.reposition();
    }
    onAnimationStart() {
        this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');
    }
    onAnimationEnd() {
        this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');
        this.open.emit();
        this.open.complete();
    }
    get currentOffset() {
        return this._currentOffset;
    }
    set currentOffset(offset$$1) {
        this.setContainerStyle('left', `${offset$$1.left}px`);
        this.setContainerStyle('top', `${offset$$1.top}px`);
        this._currentOffset = offset$$1;
    }
    setZIndex() {
        if (this.anchor) {
            this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));
        }
    }
    reposition() {
        if (!isDocumentAvailable()) {
            return;
        }
        const { flip, offset: offset$$1 } = this.position();
        if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {
            this.currentOffset = offset$$1;
            if (hasObservers(this.positionChange)) {
                this._zone.run(() => this.positionChange.emit({ offset: offset$$1, flip }));
            }
        }
        if (this.animate) {
            this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);
        }
        this.resizeSensor.acceptSize();
    }
    position() {
        const alignedOffset = this._alignService.alignElement({
            anchor: this.anchor,
            anchorAlign: this.anchorAlign,
            element: this.container,
            elementAlign: this.popupAlign,
            margin: this.margin,
            offset: this.offset,
            positionMode: this.positionMode
        });
        return this._positionService.positionElement({
            anchor: this.anchor,
            anchorAlign: this.anchorAlign,
            collisions: this.collision,
            currentLocation: alignedOffset,
            element: this.container,
            elementAlign: this.popupAlign,
            margin: this.margin
        });
    }
    onScroll(isInViewPort) {
        const hasLeaveObservers = hasObservers(this.anchorViewportLeave);
        if (isInViewPort || !hasLeaveObservers) {
            this.reposition();
        }
        else if (hasLeaveObservers) {
            this._zone.run(() => {
                this.anchorViewportLeave.emit();
            });
        }
    }
    copyFontStyles() {
        if (!this.anchor || !this.copyAnchorStyles) {
            return;
        }
        this.domService.getFontStyles(this.anchor)
            .forEach(s => this.setContainerStyle(s.key, s.value));
    }
    updateFixedClass() {
        const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';
        this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);
    }
    setContainerStyle(name, value) {
        this._renderer.setStyle(this.container.nativeElement, name, value);
    }
    unsubscribeReposition() {
        if (this.repositionSubscription) {
            this.repositionSubscription.unsubscribe();
        }
    }
}
PopupComponent.ɵfac = function PopupComponent_Factory(t) { return new (t || PopupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(AlignService), ɵngcc0.ɵɵdirectiveInject(DOMService), ɵngcc0.ɵɵdirectiveInject(PositionService), ɵngcc0.ɵɵdirectiveInject(ResizeService), ɵngcc0.ɵɵdirectiveInject(ScrollableService), ɵngcc0.ɵɵdirectiveInject(AnimationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
PopupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PopupComponent, selectors: [["kendo-popup"]], viewQuery: function PopupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(ResizeSensorComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeSensor = _t.first);
    } }, inputs: { animate: "animate", anchorAlign: "anchorAlign", collision: "collision", popupAlign: "popupAlign", copyAnchorStyles: "copyAnchorStyles", positionMode: "positionMode", offset: "offset", anchor: "anchor", popupClass: "popupClass", margin: "margin" }, outputs: { anchorViewportLeave: "anchorViewportLeave", close: "close", open: "open", positionChange: "positionChange" }, exportAs: ["kendo-popup"], features: [ɵngcc0.ɵɵProvidersFeature([AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 5, vars: 4, consts: [[1, "k-popup", 3, "ngClass"], ["container", ""], [3, "ngTemplateOutlet", "ngIf"], [3, "rateLimit", "resize"]], template: function PopupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵtemplate(3, PopupComponent_ng_template_3_Template, 0, 0, "ng-template", 2);
        ɵngcc0.ɵɵelementStart(4, "kendo-resize-sensor", 3);
        ɵngcc0.ɵɵlistener("resize", function PopupComponent_Template_kendo_resize_sensor_resize_4_listener() { return ctx.onResize(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.popupClass);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.content)("ngIf", ctx.content);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("rateLimit", 100);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, ɵngcc3.ResizeSensorComponent], encapsulation: 2 });
/** @nocollapse */
PopupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: AlignService },
    { type: DOMService },
    { type: PositionService },
    { type: ResizeService },
    { type: ScrollableService },
    { type: AnimationService },
    { type: Renderer2 },
    { type: NgZone }
];
PopupComponent.propDecorators = {
    animate: [{ type: Input }],
    anchor: [{ type: Input }],
    anchorAlign: [{ type: Input }],
    collision: [{ type: Input }],
    popupAlign: [{ type: Input }],
    copyAnchorStyles: [{ type: Input }],
    popupClass: [{ type: Input }],
    positionMode: [{ type: Input }],
    offset: [{ type: Input }],
    margin: [{ type: Input }],
    anchorViewportLeave: [{ type: Output }],
    close: [{ type: Output }],
    open: [{ type: Output }],
    positionChange: [{ type: Output }],
    contentContainer: [{ type: ViewChild, args: ['container',] }],
    resizeSensor: [{ type: ViewChild, args: [ResizeSensorComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopupComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendo-popup',
                providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],
                selector: 'kendo-popup',
                template: `
        <div class="k-popup" [ngClass]="popupClass" #container>
            <ng-content></ng-content>
            <ng-template [ngTemplateOutlet]="content" [ngIf]="content"></ng-template>
            <kendo-resize-sensor [rateLimit]="100" (resize)="onResize()">
            </kendo-resize-sensor>
        </div>
     `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: AlignService }, { type: DOMService }, { type: PositionService }, { type: ResizeService }, { type: ScrollableService }, { type: AnimationService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { animate: [{
            type: Input
        }], anchorAlign: [{
            type: Input
        }], collision: [{
            type: Input
        }], popupAlign: [{
            type: Input
        }], copyAnchorStyles: [{
            type: Input
        }], positionMode: [{
            type: Input
        }], offset: [{
            type: Input
        }], anchorViewportLeave: [{
            type: Output
        }], close: [{
            type: Output
        }], open: [{
            type: Output
        }], positionChange: [{
            type: Output
        }], anchor: [{
            type: Input
        }], popupClass: [{
            type: Input
        }], margin: [{
            type: Input
        }], contentContainer: [{
            type: ViewChild,
            args: ['container']
        }], resizeSensor: [{
            type: ViewChild,
            args: [ResizeSensorComponent]
        }] }); })();

const removeElement = (element) => {
    if (element && element.parentNode) {
        element.parentNode.removeChild(element);
    }
};
/**
 * Used to inject the Popup container. If not provided, the first root component of
 * the application is used.
 *
 * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Popup module
 * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { ElementRef, NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, PopupModule], // import Popup module
 *     bootstrap:    [AppComponent],
 *     providers: [{
 *       provide: POPUP_CONTAINER,
 *       useFactory: () => {
 *          //return the container ElementRef, where the popup will be injected
 *          return { nativeElement: document.body } as ElementRef;
 *       }
 *     }]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 * ```
 */
const POPUP_CONTAINER = new InjectionToken('Popup Container');
/**
 * A service for opening Popup components dynamically
 * ([see example]({% slug service_popup %})).
 *
 * @export
 * @class PopupService
 */
class PopupService {
    constructor(applicationRef, componentFactoryResolver, injector, container) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.container = container;
    }
    /**
     * Gets the root view container into which the component will be injected.
     *
     * @returns {ComponentRef<any>}
     */
    get rootViewContainer() {
        // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571
        const rootComponents = this.applicationRef.components || [];
        if (rootComponents[0]) {
            return rootComponents[0];
        }
        throw new Error(`
            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.
            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.
        `);
    }
    /**
     * Sets or gets the HTML element of the root component container.
     *
     * @returns {HTMLElement}
     */
    get rootViewContainerNode() {
        return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);
    }
    /**
     * Opens a Popup component. Created Popups are mounted
     * in the DOM directly in the root application component.
     *
     * @param {PopupSettings} options - The options which define the Popup.
     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.
     *
     * @example
     *
     * ```ts-no-run
     * _@Component({
     *   selector: 'my-app',
     *   template: `
     *     <ng-template #template>
     *      Popup content
     *     </ng-template>
     *     <button #anchor kendoButton (click)="open(anchor, template)">Open</button>
     *   `
     * })
     * export class AppComponent {
     *     public popupRef: PopupRef;
     *
     *     constructor( private popupService: PopupService ) {}
     *
     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {
     *         if (this.popupRef) {
     *              this.popupRef.close();
     *              this.popupRef = null;
     *              return;
     *         }
     *
     *         this.popupRef = this.popupService.open({
     *           anchor: anchor,
     *           content: template
     *         });
     *     }
     * }
     * ```
     */
    open(options = {}) {
        const { component, nodes } = this.contentFrom(options.content);
        const popupComponentRef = this.appendPopup(nodes, options.appendTo);
        const popupInstance = popupComponentRef.instance;
        this.projectComponentInputs(popupComponentRef, options);
        popupComponentRef.changeDetectorRef.detectChanges();
        if (component) {
            component.changeDetectorRef.detectChanges();
        }
        const popupElement = this.getComponentRootNode(popupComponentRef);
        return {
            close: () => {
                if (component) {
                    component.destroy();
                }
                popupComponentRef.destroy();
                // Angular will not remove the element unless the change detection is triggered
                removeElement(popupElement);
            },
            content: component,
            popup: popupComponentRef,
            popupAnchorViewportLeave: popupInstance.anchorViewportLeave,
            popupClose: popupInstance.close,
            popupElement: popupElement,
            popupOpen: popupInstance.open,
            popupPositionChange: popupInstance.positionChange
        };
    }
    appendPopup(nodes, container) {
        const popupComponentRef = this.createComponent(PopupComponent, nodes, container);
        if (!container) {
            this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));
        }
        return popupComponentRef;
    }
    /**
     * Gets the HTML element for a component reference.
     *
     * @param {ComponentRef<any>} componentRef
     * @returns {HTMLElement}
     */
    getComponentRootNode(componentRef) {
        return componentRef.location.nativeElement;
    }
    /**
     * Gets the `ComponentFactory` instance by its type.
     *
     * @param {*} componentClass
     * @param {*} nodes
     * @returns {ComponentRef<any>}
     */
    getComponentFactory(componentClass) {
        return this.componentFactoryResolver.resolveComponentFactory(componentClass);
    }
    /**
     * Creates a component reference from a `Component` type class.
     *
     * @param {*} componentClass
     * @param {*} nodes
     * @returns {ComponentRef<any>}
     */
    createComponent(componentClass, nodes, container) {
        const factory = this.getComponentFactory(componentClass);
        if (container) {
            return container.createComponent(factory, undefined, this.injector, nodes);
        }
        else {
            const component = factory.create(this.injector, nodes);
            this.applicationRef.attachView(component.hostView);
            return component;
        }
    }
    /**
     * Projects the inputs on the component.
     *
     * @param {ComponentRef<any>} component
     * @param {*} options
     * @returns {ComponentRef<any>}
     */
    projectComponentInputs(component, options) {
        Object.getOwnPropertyNames(options)
            .filter(prop => prop !== 'content' || options.content instanceof TemplateRef)
            .map((prop) => {
            component.instance[prop] = options[prop];
        });
        return component;
    }
    /**
     * Gets the component and the nodes to append from the `content` option.
     *
     * @param {*} content
     * @returns {any}
     */
    contentFrom(content) {
        if (!content || content instanceof TemplateRef) {
            return { component: null, nodes: [[]] };
        }
        const component = this.createComponent(content);
        const nodes = component ? [component.location.nativeElement] : [];
        return {
            component: component,
            nodes: [
                nodes // <ng-content>
            ]
        };
    }
}
PopupService.ɵfac = function PopupService_Factory(t) { return new (t || PopupService)(ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(POPUP_CONTAINER, 8)); };
PopupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PopupService, factory: PopupService.ɵfac });
/** @nocollapse */
PopupService.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: ElementRef, decorators: [{ type: Inject, args: [POPUP_CONTAINER,] }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopupService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [POPUP_CONTAINER]
            }, {
                type: Optional
            }] }]; }, null); })();

const POPUP_DIRECTIVES = [PopupComponent];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Popup component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Popup module
 * import { PopupModule } from '@progress/kendo-angular-popup';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, PopupModule], // import Popup module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class PopupModule {
}
PopupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PopupModule });
PopupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PopupModule_Factory(t) { return new (t || PopupModule)(); }, providers: [PopupService], imports: [[CommonModule, ResizeSensorModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PopupModule, { declarations: function () { return [PopupComponent]; }, imports: function () { return [CommonModule, ResizeSensorModule]; }, exports: function () { return [PopupComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PopupModule, [{
        type: NgModule,
        args: [{
                declarations: [POPUP_DIRECTIVES],
                entryComponents: [POPUP_DIRECTIVES],
                exports: [POPUP_DIRECTIVES],
                imports: [CommonModule, ResizeSensorModule],
                providers: [PopupService]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzswQkFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29HQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkdBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VHQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzZGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUhBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7NkZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0hBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O2lGQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytIQWVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29HQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzswQkFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3QsIE9wdGlvbmFsLCBOZ1pvbmUsIEV2ZW50RW1pdHRlciwgaXNEZXZNb2RlLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkLCBUZW1wbGF0ZVJlZiwgQXBwbGljYXRpb25SZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgSW5qZWN0b3IsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBzaWJsaW5nQ29udGFpbmVyLCBwYXJlbnRzLCBhZGRTY3JvbGwsIGFsaWduLCBib3VuZGluZ09mZnNldCwgb2Zmc2V0LCBwb3NpdGlvbldpdGhTY3JvbGwsIHJlbW92ZVNjcm9sbCwgcmVzdHJpY3RUb1ZpZXcsIHNjcm9sbFBvc2l0aW9uLCBnZXRXaW5kb3dWaWV3UG9ydCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1wb3B1cC1jb21tb24nO1xuaW1wb3J0IHsgaXNEb2N1bWVudEF2YWlsYWJsZSwgaGFzT2JzZXJ2ZXJzLCBSZXNpemVTZW5zb3JDb21wb25lbnQsIFJlc2l6ZVNlbnNvck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBmcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBzdHlsZSwgYW5pbWF0ZSwgQW5pbWF0aW9uQnVpbGRlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGVpdGhlclJlY3QgPSAocmVjdCwgb2Zmc2V0JCQxKSA9PiB7XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybiB7IGhlaWdodDogMCwgbGVmdDogb2Zmc2V0JCQxLmxlZnQsIHRvcDogb2Zmc2V0JCQxLnRvcCwgd2lkdGg6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHJlbW92ZVN0YWNraW5nT2Zmc2V0ID0gKHJlY3QsIHN0YWNraW5nT2Zmc2V0KSA9PiB7XG4gICAgaWYgKCFzdGFja2luZ09mZnNldCkge1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBzdGFja2luZ09mZnNldC5sZWZ0LFxuICAgICAgICB0b3A6IHJlY3QudG9wIC0gc3RhY2tpbmdPZmZzZXQudG9wLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNEaWZmZXJlbnRPZmZzZXQgPSAob2xkT2Zmc2V0LCBuZXdPZmZzZXQpID0+IHtcbiAgICBjb25zdCB7IGxlZnQ6IG9sZExlZnQsIHRvcDogb2xkVG9wIH0gPSBvbGRPZmZzZXQ7XG4gICAgY29uc3QgeyBsZWZ0OiBuZXdMZWZ0LCB0b3A6IG5ld1RvcCB9ID0gbmV3T2Zmc2V0O1xuICAgIHJldHVybiBNYXRoLmFicyhvbGRMZWZ0IC0gbmV3TGVmdCkgPj0gMSB8fCBNYXRoLmFicyhvbGRUb3AgLSBuZXdUb3ApID49IDE7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzV2luZG93QXZhaWxhYmxlID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgT1ZFUkZMT1dfUkVHRVhQID0gL2F1dG98c2Nyb2xsLztcbmNvbnN0IG92ZXJmbG93RWxlbWVudFN0eWxlID0gKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gYCR7ZWxlbWVudC5zdHlsZS5vdmVyZmxvd30ke2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dYfSR7ZWxlbWVudC5zdHlsZS5vdmVyZmxvd1l9YDtcbn07XG5jb25zdCBvdmVyZmxvd0NvbXB1dGVkU3R5bGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHJldHVybiBgJHtzdHlsZXMub3ZlcmZsb3d9JHtzdHlsZXMub3ZlcmZsb3dYfSR7c3R5bGVzLm92ZXJmbG93WX1gO1xufTtcbmNvbnN0IG92ZXJmbG93U3R5bGUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBvdmVyZmxvd0VsZW1lbnRTdHlsZShlbGVtZW50KSB8fCBvdmVyZmxvd0NvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNjcm9sbGFibGVQYXJlbnRzID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50cyA9IFtdO1xuICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICFpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRFbGVtZW50cztcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChPVkVSRkxPV19SRUdFWFAudGVzdChvdmVyZmxvd1N0eWxlKHBhcmVudCkpIHx8IHBhcmVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsYWJsZScpKSB7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHBhcmVudEVsZW1lbnRzLnB1c2god2luZG93KTtcbiAgICByZXR1cm4gcGFyZW50RWxlbWVudHM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEZSQU1FX0RVUkFUSU9OID0gMTAwMCAvIDYwOyAvLzEwMDBtcyBkaXZpZGVkIGJ5IDYwZnBzXG5mdW5jdGlvbiBtZW1vaXplKGZ1bikge1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGZ1biguLi5hcmdzKTtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc1JlbGF0aXZlU3RhY2tpbmdDb250ZXh0ID0gbWVtb2l6ZSgoKSA9PiB7XG4gICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkgJiYgZG9jdW1lbnQuYm9keSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IDEwO1xuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcGFyZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwibWF0cml4KDEwLCAwLCAwLCAxMCwgMCwgMClcIjtcbiAgICBwYXJlbnQuaW5uZXJIVE1MID0gYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogJHt0b3B9cHg7XCI+Y2hpbGQ8L2Rpdj5gO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50KTtcbiAgICBjb25zdCBpc0RpZmZlcmVudCA9IHBhcmVudC5jaGlsZHJlblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xufSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgekluZGV4ID0gKGFuY2hvciwgY29udGFpbmVyKSA9PiB7XG4gICAgaWYgKCFhbmNob3IgfHwgIWlzRG9jdW1lbnRBdmFpbGFibGUoKSB8fCAhaXNXaW5kb3dBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdDb250YWluZXIoYW5jaG9yLCBjb250YWluZXIpO1xuICAgIGlmICghc2libGluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW2FuY2hvcl0uY29uY2F0KHBhcmVudHMoYW5jaG9yLCBzaWJsaW5nKSkucmVkdWNlKChpbmRleCwgcCkgPT4ge1xuICAgICAgICBjb25zdCB6SW5kZXhTdHlsZSA9IHAuc3R5bGUuekluZGV4IHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHApLnpJbmRleDtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhcnNlSW50KHpJbmRleFN0eWxlLCAxMCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID4gaW5kZXggPyBjdXJyZW50IDogaW5kZXg7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdCA/IChyZXN1bHQgKyAxKSA6IG51bGw7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHNjYWxlUmVjdCA9IChyZWN0LCBzY2FsZSkgPT4ge1xuICAgIGlmICghcmVjdCB8fCBzY2FsZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHNjYWxlLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLyBzY2FsZSxcbiAgICAgICAgdG9wOiByZWN0LnRvcCAvIHNjYWxlLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHNjYWxlXG4gICAgfTtcbn07XG5cbmNvbnN0IFNUWUxFUyA9IFtcbiAgICAnZm9udC1zaXplJyxcbiAgICAnZm9udC1mYW1pbHknLFxuICAgICdmb250LXN0cmV0Y2gnLFxuICAgICdmb250LXN0eWxlJyxcbiAgICAnZm9udC13ZWlnaHQnLFxuICAgICdsaW5lLWhlaWdodCdcbl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRE9NU2VydmljZSB7XG4gICAgYWRkT2Zmc2V0KGN1cnJlbnQsIGFkZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBjdXJyZW50LmxlZnQgKyBhZGRpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBjdXJyZW50LnRvcCArIGFkZGl0aW9uLnRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRTY3JvbGwocmVjdCwgc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBhZGRTY3JvbGwocmVjdCwgc2Nyb2xsKTtcbiAgICB9XG4gICAgYWxpZ24oc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduKHNldHRpbmdzKTtcbiAgICB9XG4gICAgYm91bmRpbmdPZmZzZXQoZWwpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nT2Zmc2V0KHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICBnZXRGb250U3R5bGVzKGVsKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMuZ2V0V2luZG93KCk7XG4gICAgICAgIGlmICghd2luZG93IHx8ICFlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgICAgIHJldHVybiBTVFlMRVMubWFwKGZvbnQgPT4gKHsga2V5OiBmb250LCB2YWx1ZTogY29tcHV0ZWRTdHlsZXNbZm9udF0gfSkpO1xuICAgIH1cbiAgICBnZXRXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiBpc1dpbmRvd0F2YWlsYWJsZSgpID8gd2luZG93IDogbnVsbDtcbiAgICB9XG4gICAgaGFzT2Zmc2V0UGFyZW50KGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgb2Zmc2V0KGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQodGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIG9mZnNldEF0UG9pbnQoZWwsIGN1cnJlbnRMb2NhdGlvbikge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50KGVsKTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCB0b3AsIHRyYW5zaXRpb24gfSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7Y3VycmVudExvY2F0aW9uLmxlZnR9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IGAke2N1cnJlbnRMb2NhdGlvbi50b3B9cHhgO1xuICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gb2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IHRvcDtcbiAgICAgICAgLy8gcHJldmVudHMgZWxlbWVudHMgd2l0aCB0cmFuc2l0aW9uIHRvIGJlIGFuaW1hdGVkIGJlY2F1c2Ugb2YgdGhlIGNoYW5nZVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgIHJldHVybiBjdXJyZW50T2Zmc2V0O1xuICAgIH1cbiAgICBuYXRpdmVFbGVtZW50KGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5uYXRpdmVFbGVtZW50IHx8IGVsO1xuICAgIH1cbiAgICBwb3NpdGlvbihlbGVtZW50LCBwb3B1cCwgc2NhbGUgPSAxKSB7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhcG9wdXApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbldpdGhTY3JvbGwodGhpcy5uYXRpdmVFbGVtZW50KGVsZW1lbnQpLCB0aGlzLm5hdGl2ZUVsZW1lbnQocG9wdXApLCBzY2FsZSk7XG4gICAgfVxuICAgIHJlbW92ZVNjcm9sbChyZWN0LCBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbChyZWN0LCBzY3JvbGwpO1xuICAgIH1cbiAgICByZXN0cmljdFRvVmlldyhzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gcmVzdHJpY3RUb1ZpZXcoc2V0dGluZ3MpO1xuICAgIH1cbiAgICBzY3JvbGxQb3NpdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsUG9zaXRpb24odGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIHNjcm9sbGFibGVQYXJlbnRzKGVsKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxhYmxlUGFyZW50cyh0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICB9XG4gICAgc3RhY2tpbmdFbGVtZW50T2Zmc2V0KGVsKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQgPSB0aGlzLmdldFJlbGF0aXZlQ29udGV4dEVsZW1lbnQoZWwpO1xuICAgICAgICBpZiAoIXJlbGF0aXZlQ29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQocmVsYXRpdmVDb250ZXh0RWxlbWVudCk7XG4gICAgfVxuICAgIHN0YWNraW5nRWxlbWVudFNjcm9sbChlbCkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbnRleHRFbGVtZW50ID0gdGhpcy5nZXRSZWxhdGl2ZUNvbnRleHRFbGVtZW50KGVsKTtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZUNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJlbGF0aXZlQ29udGV4dEVsZW1lbnQoZWwpIHtcbiAgICAgICAgaWYgKCFlbCB8fCAhaGFzUmVsYXRpdmVTdGFja2luZ0NvbnRleHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMubmF0aXZlRWxlbWVudChlbCkucGFyZW50RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCkudHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZVJlbGF0aXZlUG9zaXRpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRSZWxhdGl2ZUNvbnRleHRFbGVtZW50KGVsKTtcbiAgICB9XG4gICAgd2luZG93Vmlld1BvcnQoZWwpIHtcbiAgICAgICAgcmV0dXJuIGdldFdpbmRvd1ZpZXdQb3J0KHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICB6SW5kZXgoYW5jaG9yLCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHpJbmRleCh0aGlzLm5hdGl2ZUVsZW1lbnQoYW5jaG9yKSwgdGhpcy5uYXRpdmVFbGVtZW50KGNvbnRhaW5lcikpO1xuICAgIH1cbiAgICB6b29tTGV2ZWwoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICFpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC8gd2luZG93LmlubmVyV2lkdGgpLnRvRml4ZWQoMikpIHx8IDE7XG4gICAgfVxuICAgIGlzWm9vbWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tTGV2ZWwoKSA+IDE7XG4gICAgfVxufVxuRE9NU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBVc2VkIHRvIHNldCB0aGUgZG9jdW1lbnQgc2NhbGUgd2hlbiB1c2luZyBhIFtzY2FsZSB0cmFuc2Zvcm1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0tZnVuY3Rpb24vc2NhbGUpLlxuICpcbiAqIFRoZSBkb2N1bWVudCBvciBjb250YWluZXIgc2NhbGUgaXMgcmVxdWlyZWQgdG8gY29tcHV0ZSB0aGUgcG9wdXAgcG9zaXRpb24gY29ycmVjdGx5LiBEZXRlY3RpbmcgdGhlIHNjYWxlIGlzIG5vdCByZWxpYWJsZSBhbmQgbXVzdCBiZSBzZXQgYnkgcHJvdmlkaW5nIGEgdmFsdWUgZm9yIFNDQUxFLiBTZWUgW1N1cHBvcnQgZm9yIERvY3VtZW50IFNjYWxlXSh7JSBzbHVnIGRvY3VtZW50c2NhbGVfcG9wdXAgJX0pLlxuICpcbiAqID4gVXNpbmcgdGhpcyB0b2tlbiBpcyBub3QgbmVjZXNzYXJ5IGZvciB1c2VyLWFwcGxpZWQgYnJvd3NlciB6b29tLlxuICpcbiAqIHslIG1ldGEgaGVpZ2h0OjMwMCAlfVxuICogeyUgZW1iZWRfZmlsZSBzY2FsZS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAqIHslIGVtYmVkX2ZpbGUgc2NhbGUvYXBwLm1vZHVsZS50cyAlfVxuICogeyUgZW1iZWRfZmlsZSBzY2FsZS9tYWluLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKlxuICpcbiAqL1xuY29uc3QgU0NBTEUgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1BvcHVwIERvY3VtZW50IFNjYWxlJyk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBBbGlnblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb20sIHNjYWxlID0gMSkge1xuICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgfVxuICAgIGFsaWduRWxlbWVudChzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB7IGFuY2hvciwgZWxlbWVudCwgYW5jaG9yQWxpZ24sIGVsZW1lbnRBbGlnbiwgbWFyZ2luLCBvZmZzZXQ6IG9mZnNldCQkMSwgcG9zaXRpb25Nb2RlIH0gPSBzZXR0aW5ncztcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlIHx8IDE7XG4gICAgICAgIGNvbnN0IGZpeGVkTW9kZSA9IHBvc2l0aW9uTW9kZSA9PT0gJ2ZpeGVkJyB8fCAhdGhpcy5fZG9tLmhhc09mZnNldFBhcmVudChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgYW5jaG9yUmVjdCA9IGZpeGVkTW9kZSA/IHRoaXMuYWJzb2x1dGVSZWN0KGFuY2hvciwgZWxlbWVudCwgb2Zmc2V0JCQxLCBzY2FsZSkgOiB0aGlzLnJlbGF0aXZlUmVjdChhbmNob3IsIGVsZW1lbnQsIG9mZnNldCQkMSwgc2NhbGUpO1xuICAgICAgICBjb25zdCBlbGVtZW50UmVjdCA9IHNjYWxlUmVjdCh0aGlzLl9kb20ub2Zmc2V0KGVsZW1lbnQpLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RvbS5hbGlnbih7XG4gICAgICAgICAgICBhbmNob3JBbGlnbjogYW5jaG9yQWxpZ24sXG4gICAgICAgICAgICBhbmNob3JSZWN0OiBhbmNob3JSZWN0LFxuICAgICAgICAgICAgZWxlbWVudEFsaWduOiBlbGVtZW50QWxpZ24sXG4gICAgICAgICAgICBlbGVtZW50UmVjdDogZWxlbWVudFJlY3QsXG4gICAgICAgICAgICBtYXJnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFic29sdXRlUmVjdChhbmNob3IsIGVsZW1lbnQsIG9mZnNldCQkMSwgc2NhbGUpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsUG9zID0gdGhpcy5lbGVtZW50U2Nyb2xsUG9zaXRpb24oYW5jaG9yLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgcmVjdCA9IGVpdGhlclJlY3QodGhpcy5fZG9tLm9mZnNldChhbmNob3IpLCBvZmZzZXQkJDEpO1xuICAgICAgICBjb25zdCBzdGFja1NjYWxlID0gMiAqIHNjYWxlO1xuICAgICAgICBjb25zdCBzdGFja1Njcm9sbCA9IHRoaXMuX2RvbS5zdGFja2luZ0VsZW1lbnRTY3JvbGwoZWxlbWVudCk7XG4gICAgICAgIGlmIChzY2FsZSAhPT0gMSAmJiBzdGFja1Njcm9sbCkge1xuICAgICAgICAgICAgc3RhY2tTY3JvbGwueCAvPSBzdGFja1NjYWxlO1xuICAgICAgICAgICAgc3RhY2tTY3JvbGwueSAvPSBzdGFja1NjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWNrT2Zmc2V0ID0gdGhpcy5fZG9tLnN0YWNraW5nRWxlbWVudE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxICYmIHN0YWNrT2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFja09mZnNldC5sZWZ0IC89IHN0YWNrU2NhbGU7XG4gICAgICAgICAgICBzdGFja09mZnNldC50b3AgLz0gc3RhY2tTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZG9tLnJlbW92ZVNjcm9sbCh0aGlzLl9kb20uYWRkU2Nyb2xsKHJlbW92ZVN0YWNraW5nT2Zmc2V0KHNjYWxlUmVjdChyZWN0LCBzY2FsZSksIHN0YWNrT2Zmc2V0KSwgc3RhY2tTY3JvbGwpLCBzY3JvbGxQb3MpO1xuICAgIH1cbiAgICBlbGVtZW50U2Nyb2xsUG9zaXRpb24oYW5jaG9yLCBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhbmNob3IgPyB7IHg6IDAsIHk6IDAgfSA6IHRoaXMuX2RvbS5zY3JvbGxQb3NpdGlvbihlbGVtZW50KTtcbiAgICB9XG4gICAgcmVsYXRpdmVSZWN0KGFuY2hvciwgZWxlbWVudCwgb2Zmc2V0JCQxLCBzY2FsZSkge1xuICAgICAgICBjb25zdCByZWN0ID0gZWl0aGVyUmVjdCh0aGlzLl9kb20ucG9zaXRpb24oYW5jaG9yLCBlbGVtZW50LCBzY2FsZSksIG9mZnNldCQkMSk7XG4gICAgICAgIHJldHVybiBzY2FsZVJlY3QocmVjdCwgc2NhbGUpO1xuICAgIH1cbn1cbkFsaWduU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQWxpZ25TZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRE9NU2VydmljZSB9LFxuICAgIHsgdHlwZTogTnVtYmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtTQ0FMRSxdIH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBvc2l0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2RvbSwgc2NhbGUgPSAxKSB7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB9XG4gICAgcG9zaXRpb25FbGVtZW50KHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgYW5jaG9yLCBjdXJyZW50TG9jYXRpb24sIGVsZW1lbnQsIGFuY2hvckFsaWduLCBlbGVtZW50QWxpZ24sIGNvbGxpc2lvbnMsIG1hcmdpbiB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGNvbnN0IGRvbSA9IHRoaXMuX2RvbTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNjYWxlIHx8IDE7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRPZmZzZXQgPSBkb20ub2Zmc2V0QXRQb2ludChlbGVtZW50LCBjdXJyZW50TG9jYXRpb24pO1xuICAgICAgICBjb25zdCBlbGVtZW50UmVjdCA9IHNjYWxlUmVjdChlbGVtZW50T2Zmc2V0LCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IHNjYWxlUmVjdChkb20ub2Zmc2V0KGFuY2hvciksIHNjYWxlKTtcbiAgICAgICAgY29uc3QgYW5jaG9yUmVjdCA9IGVpdGhlclJlY3QoYW5jaG9yT2Zmc2V0LCBjdXJyZW50TG9jYXRpb24pO1xuICAgICAgICBjb25zdCB2aWV3UG9ydCA9IHNldHRpbmdzLnZpZXdQb3J0IHx8IGRvbS53aW5kb3dWaWV3UG9ydChlbGVtZW50KTtcbiAgICAgICAgdmlld1BvcnQud2lkdGggPSB2aWV3UG9ydC53aWR0aCAvIHNjYWxlO1xuICAgICAgICB2aWV3UG9ydC5oZWlnaHQgPSB2aWV3UG9ydC5oZWlnaHQgLyBzY2FsZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZG9tLnJlc3RyaWN0VG9WaWV3KHtcbiAgICAgICAgICAgIGFuY2hvckFsaWduLFxuICAgICAgICAgICAgYW5jaG9yUmVjdCxcbiAgICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgICBlbGVtZW50QWxpZ24sXG4gICAgICAgICAgICBlbGVtZW50UmVjdCxcbiAgICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICAgIHZpZXdQb3J0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvZmZzZXQkJDEgPSBkb20uYWRkT2Zmc2V0KGN1cnJlbnRMb2NhdGlvbiwgcmVzdWx0Lm9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGlwOiByZXN1bHQuZmxpcCxcbiAgICAgICAgICAgIGZsaXBwZWQ6IHJlc3VsdC5mbGlwcGVkLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQkJDFcbiAgICAgICAgfTtcbiAgICB9XG59XG5Qb3NpdGlvblNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBvc2l0aW9uU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERPTVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE51bWJlciwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbU0NBTEUsXSB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihfZG9tLCBfem9uZSkge1xuICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgfVxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQodGhpcy5fZG9tLmdldFdpbmRvdygpLCBcInJlc2l6ZVwiKVxuICAgICAgICAgICAgICAgIC5waXBlKGF1ZGl0VGltZShGUkFNRV9EVVJBVElPTikpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaXNVbnN1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbiAmJiB0aGlzLnN1YnNjcmlwdGlvbi5jbG9zZWQ7XG4gICAgfVxufVxuUmVzaXplU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUmVzaXplU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERPTVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgVEhSRVNIT0xEX0RJRkYgPSAxO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNjcm9sbGFibGVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihfZG9tLCBfem9uZSkge1xuICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgfVxuICAgIGZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAhaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5fZG9tLm5hdGl2ZUVsZW1lbnQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgY29uc3QgcGFyZW50cyQkMSA9IHRoaXMuX2RvbS5zY3JvbGxhYmxlUGFyZW50cyh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGVzID0gcGFyZW50cyQkMS5tYXAocCA9PiBmcm9tRXZlbnQocCwgXCJzY3JvbGxcIikucGlwZShhdWRpdFRpbWUoRlJBTUVfRFVSQVRJT04pKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1BhcmVudCA9IHBhcmVudHMkJDEuZmlsdGVyKHAgPT4gcCA9PT0gdGFyZ2V0KS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRG9jdW1lbnQgPSB0YXJnZXQgPT09IGRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzV2luZG93ID0gdGFyZ2V0ID09PSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFyZW50IHx8IGlzRG9jdW1lbnQgfHwgaXNXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5pc1Zpc2libGUobmF0aXZlRWxlbWVudCwgdGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbWVyZ2UoLi4ub2JzZXJ2YWJsZXMpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaXNWaXNpYmxlKGVsZW0sIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBlbGVtUmVjdCA9IHRoaXMuX2RvbS5ib3VuZGluZ09mZnNldChlbGVtKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IHRoaXMuX2RvbS5ib3VuZGluZ09mZnNldChjb250YWluZXIpO1xuICAgICAgICBpZiAoVEhSRVNIT0xEX0RJRkYgPCAoY29udGFpbmVyUmVjdC50b3AgLSBlbGVtUmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRIUkVTSE9MRF9ESUZGIDwgKGVsZW1SZWN0LnRvcCAtIGNvbnRhaW5lclJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUSFJFU0hPTERfRElGRiA8IChlbGVtUmVjdC5sZWZ0IC0gY29udGFpbmVyUmVjdC5yaWdodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVEhSRVNIT0xEX0RJRkYgPCAoY29udGFpbmVyUmVjdC5sZWZ0IC0gZWxlbVJlY3QucmlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuU2Nyb2xsYWJsZVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblNjcm9sbGFibGVTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRE9NU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5cbmNvbnN0IExFRlQgPSAnbGVmdCc7XG5jb25zdCBSSUdIVCA9ICdyaWdodCc7XG5jb25zdCBET1dOID0gJ2Rvd24nO1xuY29uc3QgVVAgPSAndXAnO1xuY29uc3QgREVGQVVMVF9UWVBFID0gJ3NsaWRlJztcbmNvbnN0IERFRkFVTFRfRFVSQVRJT04gPSAxMDA7XG5jb25zdCBhbmltYXRpb25UeXBlcyA9IHt9O1xuLyogdHNsaW50OmRpc2FibGU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzICovXG5hbmltYXRpb25UeXBlcy5leHBhbmQgPSAoZGlyZWN0aW9uKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBkaXJlY3Rpb24gPT09IFVQIHx8IGRpcmVjdGlvbiA9PT0gRE9XTiA/ICdzY2FsZVknIDogJ3NjYWxlWCc7XG4gICAgY29uc3Qgc3RhcnRTY2FsZSA9IDA7XG4gICAgY29uc3QgZW5kU2NhbGUgPSAxO1xuICAgIGxldCBvcmlnaW47XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICBvcmlnaW4gPSAndG9wJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgIG9yaWdpbiA9IFJJR0hUO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgIG9yaWdpbiA9IExFRlQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcmlnaW4gPSAnYm90dG9tJztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHsgdHJhbnNmb3JtOiBgJHtzY2FsZX0oJHtzdGFydFNjYWxlfSlgLCB0cmFuc2Zvcm1PcmlnaW46IG9yaWdpbiB9LFxuICAgICAgICBlbmQ6IHsgdHJhbnNmb3JtOiBgJHtzY2FsZX0oJHtlbmRTY2FsZX0pYCB9XG4gICAgfTtcbn07XG5hbmltYXRpb25UeXBlcy5zbGlkZSA9IChkaXJlY3Rpb24pID0+IHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBkaXJlY3Rpb24gPT09IExFRlQgfHwgZGlyZWN0aW9uID09PSBSSUdIVCA/ICd0cmFuc2xhdGVYJyA6ICd0cmFuc2xhdGVZJztcbiAgICBjb25zdCBzdGFydCA9IGRpcmVjdGlvbiA9PT0gUklHSFQgfHwgZGlyZWN0aW9uID09PSBET1dOID8gLTEwMCA6IDEwMDtcbiAgICBjb25zdCBlbmQgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7IHRyYW5zZm9ybTogYCR7dHJhbnNsYXRlfSgke3N0YXJ0fSUpYCB9LFxuICAgICAgICBlbmQ6IHsgdHJhbnNmb3JtOiBgJHt0cmFuc2xhdGV9KCR7ZW5kfSUpYCB9XG4gICAgfTtcbn07XG5hbmltYXRpb25UeXBlcy5mYWRlID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgZW5kOiB7IG9wYWNpdHk6IDEgfVxuICAgIH07XG59O1xuYW5pbWF0aW9uVHlwZXMuem9vbSA9ICgpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IDA7XG4gICAgY29uc3QgZW5kID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogeyB0cmFuc2Zvcm06IGBzY2FsZSgke3N0YXJ0fSlgIH0sXG4gICAgICAgIGVuZDogeyB0cmFuc2Zvcm06IGBzY2FsZSgke2VuZH0pYCB9XG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQW5pbWF0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYW5pbWF0aW9uQnVpbGRlcikge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkJ1aWxkZXIgPSBhbmltYXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgcGxheShlbGVtZW50LCBvcHRpb25zLCBmbGlwKSB7XG4gICAgICAgIGlmICghdGhpcy5mbGlwIHx8IHRoaXMuZmxpcC5ob3Jpem9udGFsICE9PSBmbGlwLmhvcml6b250YWwgfHxcbiAgICAgICAgICAgIHRoaXMuZmxpcC52ZXJ0aWNhbCAhPT0gZmxpcC52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5mbGlwID0gZmxpcDtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgREVGQVVMVF9UWVBFO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVzRm4gPSBhbmltYXRpb25UeXBlc1t0eXBlXTtcbiAgICAgICAgICAgIGlmIChzdGF0ZXNGbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKGZsaXAsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlcyA9IHN0YXRlc0ZuKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5U3RhdGVzKGVsZW1lbnQsIHN0YXRlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYW5pbWF0aW9uIHR5cGU6IFwiJHt0eXBlfVwiLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZSBzbGlkZSwgZXhwYW5kLCBmYWRlIGFuZCB6b29tLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3BQbGF5ZXIoKTtcbiAgICB9XG4gICAgcGxheVN0YXRlcyhlbGVtZW50LCBzdGF0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdG9wUGxheWVyKCk7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCBERUZBVUxUX0RVUkFUSU9OO1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5hbmltYXRpb25CdWlsZGVyLmJ1aWxkKFtcbiAgICAgICAgICAgIHN0eWxlKHN0YXRlcy5zdGFydCksXG4gICAgICAgICAgICBhbmltYXRlKGAke2R1cmF0aW9ufW1zIGVhc2UtaW5gLCBzdHlsZShzdGF0ZXMuZW5kKSlcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMucGxheWVyID0gZmFjdG9yeS5jcmVhdGUoZWxlbWVudCk7XG4gICAgICAgIHBsYXllci5vbkRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmQuZW1pdCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wUGxheWVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXJ0LmVtaXQoKTtcbiAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICB9XG4gICAgZ2V0RGlyZWN0aW9uKGZsaXAsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8IERPV047XG4gICAgICAgIGlmIChmbGlwLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBSSUdIVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBMRUZUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGlwLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gVVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gRE9XTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cbiAgICBzdG9wUGxheWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucGxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkFuaW1hdGlvblNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkFuaW1hdGlvblNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBBbmltYXRpb25CdWlsZGVyIH1cbl07XG5cbmNvbnN0IERFRkFVTFRfT0ZGU0VUID0geyBsZWZ0OiAtMTAwMDAsIHRvcDogMCB9O1xuY29uc3QgQU5JTUFUSU9OX0NPTlRBSU5FUiA9ICdrLWFuaW1hdGlvbi1jb250YWluZXInO1xuY29uc3QgQU5JTUFUSU9OX0NPTlRBSU5FUl9GSVhFRCA9ICdrLWFuaW1hdGlvbi1jb250YWluZXItZml4ZWQnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgUG9wdXAgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3BvcHVwICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGJ1dHRvbiAjYW5jaG9yIChjbGljayk9XCJzaG93PSFzaG93XCI+VG9nZ2xlPC9idXR0b24+XG4gKiAgPGtlbmRvLXBvcHVwICpuZ0lmPVwic2hvd1wiIFthbmNob3JdPVwiYW5jaG9yXCI+XG4gKiAgICAgIDxzdHJvbmc+UG9wdXAgY29udGVudCE8L3N0cm9uZz5cbiAqICA8L2tlbmRvLXBvcHVwPlxuICogYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBzaG93OiBib29sZWFuID0gZmFsc2U7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgUG9wdXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgX2FsaWduU2VydmljZSwgZG9tU2VydmljZSwgX3Bvc2l0aW9uU2VydmljZSwgX3Jlc2l6ZVNlcnZpY2UsIF9zY3JvbGxhYmxlU2VydmljZSwgYW5pbWF0aW9uU2VydmljZSwgX3JlbmRlcmVyLCBfem9uZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fYWxpZ25TZXJ2aWNlID0gX2FsaWduU2VydmljZTtcbiAgICAgICAgdGhpcy5kb21TZXJ2aWNlID0gZG9tU2VydmljZTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25TZXJ2aWNlID0gX3Bvc2l0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5fcmVzaXplU2VydmljZSA9IF9yZXNpemVTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9zY3JvbGxhYmxlU2VydmljZSA9IF9zY3JvbGxhYmxlU2VydmljZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TZXJ2aWNlID0gYW5pbWF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIHRoZSBQb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgICogYXJlIGVuYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbmltYXRpb25zX3BvcHVwICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhbmNob3IgcGl2b3QgcG9pbnRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtcG9zaXRpb25pbmcpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5jaG9yQWxpZ24gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICdib3R0b20nIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSBjb2xsaXNpb24gYmVoYXZpb3Igb2YgdGhlIFBvcHVwXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmlld3BvcnRib3VuZGFyeWRldGVjdGlvbl9wb3B1cCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsaXNpb24gPSB7IGhvcml6b250YWw6ICdmaXQnLCB2ZXJ0aWNhbDogJ2ZsaXAnIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHBpdm90IHBvaW50IG9mIHRoZSBQb3B1cFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1wb3NpdGlvbmluZykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3B1cEFsaWduID0geyBob3Jpem9udGFsOiAnbGVmdCcsIHZlcnRpY2FsOiAndG9wJyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgd2hldGhlciB0aGUgY29tcG9uZW50IHdpbGwgY29weSB0aGUgYGFuY2hvcmAgZm9udCBzdHlsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvcHlBbmNob3JTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcG9zaXRpb24gbW9kZSBvZiB0aGUgY29tcG9uZW50LiBCeSBkZWZhdWx0LCB0aGUgUG9wdXAgdXNlcyBmaXhlZCBwb3NpdGlvbmluZy5cbiAgICAgICAgICogVG8gbWFrZSB0aGUgUG9wdXAgYWNxdWlyZSBhYnNvbHV0ZSBwb3NpdGlvbmluZywgc2V0IHRoaXMgb3B0aW9uIHRvIGBhYnNvbHV0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBtb2JpbGUgYnJvd3NlcnMgd2l0aCB0aGUgem9vbSBvcHRpb24sXG4gICAgICAgICAqIHVzZSB0aGUgYGFic29sdXRlYCBwb3NpdGlvbmluZyBvZiB0aGUgUG9wdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGh0bWxcbiAgICAgICAgICogPHN0eWxlPlxuICAgICAgICAgKiAgLnBhcmVudC1jb250ZW50IHtcbiAgICAgICAgICogICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICogICAgIHdpZHRoOiAyMDBweDtcbiAgICAgICAgICogICAgIGhlaWdodDogMjAwcHg7XG4gICAgICAgICAqICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICogICAgIG1hcmdpbjogMjAwcHggYXV0bztcbiAgICAgICAgICogICAgIGJvcmRlcjogMXB4IHNvbGlkIHJlZDtcbiAgICAgICAgICogIH1cbiAgICAgICAgICogIC5jb250ZW50IHtcbiAgICAgICAgICogICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICogICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgICogICAgIGhlaWdodDogMTAwcHg7XG4gICAgICAgICAqICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICogICAgIG1hcmdpbjogMzAwcHg7XG4gICAgICAgICAqICAgICBib3JkZXI6IDFweCBzb2xpZCBibHVlO1xuICAgICAgICAgKiAgfVxuICAgICAgICAgKiAgLmFuY2hvciB7XG4gICAgICAgICAqICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAqICAgICB0b3A6IDIwMHB4O1xuICAgICAgICAgKiAgICAgbGVmdDogMjAwcHg7XG4gICAgICAgICAqICB9XG4gICAgICAgICAqIDwvc3R5bGU+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1jb25maWdcIj5cbiAgICAgICAgICogICAgICBQb3NpdGlvbiBtb2RlOlxuICAgICAgICAgKiAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCJmaXhlZFwiIFsobmdNb2RlbCldPVwibW9kZVwiIC8+IEZpeGVkPC9sYWJlbD5cbiAgICAgICAgICogICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIHZhbHVlPVwiYWJzb2x1dGVcIiBbKG5nTW9kZWwpXT1cIm1vZGVcIiAvPiBBYnNvbHV0ZTwvbGFiZWw+XG4gICAgICAgICAqICAgPC9kaXY+XG4gICAgICAgICAqICAgPGRpdiBjbGFzcz1cImV4YW1wbGUtY29uZmlnXCI+XG4gICAgICAgICAqICAgICAgIEFwcGVuZCB0b1xuICAgICAgICAgKiAgICAgICA8bGFiZWw+XG4gICAgICAgICAqICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cInBsYWNlXCIgW3ZhbHVlXT1cIjFcIiBbKG5nTW9kZWwpXT1cImNoZWNrZWRcIiAvPlxuICAgICAgICAgKiAgICAgICAgICAgUm9vdCBjb21wb25lbnRcbiAgICAgICAgICogICAgICAgPC9sYWJlbD5cbiAgICAgICAgICogICAgICAgPGxhYmVsPlxuICAgICAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIyXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHJlZFwiPlJlZCBDb250YWluZXI8L3NwYW4+XG4gICAgICAgICAqICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgICAgICogICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicGxhY2VcIiBbdmFsdWVdPVwiM1wiIFsobmdNb2RlbCldPVwiY2hlY2tlZFwiIC8+XG4gICAgICAgICAqICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiBibHVlXCI+Qmx1ZSBDb250YWluZXI8L3NwYW4+XG4gICAgICAgICAqICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAqICAgPC9kaXY+XG4gICAgICAgICAqICAgPGRpdiBjbGFzcz1cImV4YW1wbGVcIj5cbiAgICAgICAgICogICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQtY29udGVudFwiIFtzY3JvbGxMZWZ0XT1cIjI1MFwiIFtzY3JvbGxUb3BdPVwiMjMwXCI+XG4gICAgICAgICAqICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiBbc2Nyb2xsTGVmdF09XCIxNzBcIiBbc2Nyb2xsVG9wXT1cIjE2NVwiPlxuICAgICAgICAgKiAgICAgICAgICAgPGJ1dHRvbiAjYW5jaG9yIGNsYXNzPVwiYW5jaG9yXCIgKGNsaWNrKT1cInNob3cgPSAhc2hvd1wiPlRvZ2dsZTwvYnV0dG9uPlxuICAgICAgICAgKiAgICAgICAgICAgPGtlbmRvLXBvcHVwIFtwb3NpdGlvbk1vZGVdPVwibW9kZVwiIFthbmNob3JdPVwiYW5jaG9yXCIgKGFuY2hvclZpZXdwb3J0TGVhdmUpPVwic2hvdz1mYWxzZVwiICpuZ0lmPVwic2hvdyAmJiBjaGVja2VkID09PSAzXCI+XG4gICAgICAgICAqICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICogICAgICAgICAgICAgICAgIDxsaT5JdGVtMTwvbGk+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTI8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgPGxpPkl0ZW0zPC9saT5cbiAgICAgICAgICogICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICogICAgICAgICAgIDwva2VuZG8tcG9wdXA+XG4gICAgICAgICAqICAgICAgICAgICA8c3BhbiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA0MDBweDsgbGVmdDogNDAwcHhcIj5Cb3R0b20vUmlnaHQ8L3NwYW4+XG4gICAgICAgICAqICAgICAgICAgPC9kaXY+XG4gICAgICAgICAqICAgICAgICAgPGtlbmRvLXBvcHVwIFtwb3NpdGlvbk1vZGVdPVwibW9kZVwiIFthbmNob3JdPVwiYW5jaG9yXCIgKGFuY2hvclZpZXdwb3J0TGVhdmUpPVwic2hvdz1mYWxzZVwiICpuZ0lmPVwic2hvdyAmJiBjaGVja2VkID09PSAyXCI+XG4gICAgICAgICAqICAgICAgICAgICA8dWw+XG4gICAgICAgICAqICAgICAgICAgICAgICAgPGxpPkl0ZW0xPC9saT5cbiAgICAgICAgICogICAgICAgICAgICAgICA8bGk+SXRlbTI8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICAgIDxsaT5JdGVtMzwvbGk+XG4gICAgICAgICAqICAgICAgICAgICA8L3VsPlxuICAgICAgICAgKiAgICAgICAgIDwva2VuZG8tcG9wdXA+XG4gICAgICAgICAqICAgICAgICAgPHNwYW4gc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNjAwcHg7IGxlZnQ6IDYwMHB4XCI+Qm90dG9tL1JpZ2h0PC9zcGFuPlxuICAgICAgICAgKiAgICAgPC9kaXY+XG4gICAgICAgICAqICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDFcIj5cbiAgICAgICAgICogICAgICAgPHVsPlxuICAgICAgICAgKiAgICAgICAgICAgPGxpPkl0ZW0xPC9saT5cbiAgICAgICAgICogICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICAgICAqICAgICAgICAgICA8bGk+SXRlbTM8L2xpPlxuICAgICAgICAgKiAgICAgICA8L3VsPlxuICAgICAgICAgKiAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgICAgICogICA8L2Rpdj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBjaGVja2VkOiBudW1iZXIgPSAzO1xuICAgICAgICAgKiAgIHB1YmxpYyBtb2RlOiBzdHJpbmcgPSAnYWJzb2x1dGUnO1xuICAgICAgICAgKiAgIHB1YmxpYyBzaG93OiBib29sZWFuID0gdHJ1ZTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb25Nb2RlID0gJ2ZpeGVkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtYWxpZ25pbmctdG8tYWJzb2x1dGUtcG9pbnRzKSkuXG4gICAgICAgICAqIFRoZSBQb3B1cCBvcGVucyBuZXh0IHRvIHRoYXQgcG9pbnQuIFRoZSBQb3B1cCBwaXZvdCBwb2ludCBpcyBkZWZpbmVkIGJ5IHRoZSBgcG9wdXBBbGlnbmAgY29uZmlndXJhdGlvbiBvcHRpb24uXG4gICAgICAgICAqIFRoZSBib3VuZGFyeSBkZXRlY3Rpb24gaXMgYXBwbGllZCBieSB1c2luZyB0aGUgd2luZG93IHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBERUZBVUxUX09GRlNFVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGFuY2hvciBpcyBzY3JvbGxlZCBvdXRzaWRlIHRoZSBzY3JlZW4gYm91bmRhcmllcy5cbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjbG9zaW5nX3BvcHVwICV9I3RvYy1hZnRlci1sZWF2aW5nLXRoZS12aWV3cG9ydCkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmNob3JWaWV3cG9ydExlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBvcGVuZWQgYW5kIHRoZSBvcGVuaW5nIGFuaW1hdGlvbiBlbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBvcGVuZWQgYW5kIHRoZSBQb3B1cCBpcyBwb3NpdGlvbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbENoZWNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MoY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIEFOSU1BVElPTl9DT05UQUlORVIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpeGVkQ2xhc3MoKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucmVwb3NpdGlvbiA9IHRoaXMucmVwb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlLnN1YnNjcmliZSh0aGlzLnJlcG9zaXRpb24pO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbnMgPSB0aGlzLmFuaW1hdGlvblNlcnZpY2Uuc3RhcnQuc3Vic2NyaWJlKHRoaXMub25BbmltYXRpb25TdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb25zLmFkZCh0aGlzLmFuaW1hdGlvblNlcnZpY2UuZW5kLnN1YnNjcmliZSh0aGlzLm9uQW5pbWF0aW9uRW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZVNlcnZpY2UuZm9yRWxlbWVudCh0aGlzLmFuY2hvciB8fCB0aGlzLmNvbnRhaW5lcikuc3Vic2NyaWJlKHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudE9mZnNldCA9IERFRkFVTFRfT0ZGU0VUO1xuICAgICAgICB0aGlzLnNldFpJbmRleCgpO1xuICAgICAgICB0aGlzLmNvcHlGb250U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRml4ZWRDbGFzcygpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvcHlBbmNob3JTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29weUZvbnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRml4ZWRDbGFzcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQW5pbWF0aW9uRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxDaGVjaykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsQ2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmRzIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5MDk0XG4gICAgICAgICAgICAvLyB1c2VzIHByb21pc2UgYmVjYXVzZSBpdCBpcyBleGVjdXRlZCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjb250ZW50IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IHVzZSBvblN0YWJsZSBpbiBjYXNlIHRoZSBjdXJyZW50IHpvbmUgaXMgbm90IHRoZSBhbmd1bGFyIG9uZS5cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVSZXBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb25TdWJzY3JpcHRpb24gPSBmcm9tKHRoaXMucmVzb2x2ZWRQcm9taXNlKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5yZXBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgICAgICAgdGhpcy5jbG9zZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVTZXJ2aWNlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlUmVwb3NpdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMucmVwb3NpdGlvbigpO1xuICAgIH1cbiAgICBvbkFuaW1hdGlvblN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnay1hbmltYXRpb24tY29udGFpbmVyLXNob3duJyk7XG4gICAgfVxuICAgIG9uQW5pbWF0aW9uRW5kKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnay1hbmltYXRpb24tY29udGFpbmVyLXNob3duJyk7XG4gICAgICAgIHRoaXMub3Blbi5lbWl0KCk7XG4gICAgICAgIHRoaXMub3Blbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIHNldCBjdXJyZW50T2Zmc2V0KG9mZnNldCQkMSkge1xuICAgICAgICB0aGlzLnNldENvbnRhaW5lclN0eWxlKCdsZWZ0JywgYCR7b2Zmc2V0JCQxLmxlZnR9cHhgKTtcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXJTdHlsZSgndG9wJywgYCR7b2Zmc2V0JCQxLnRvcH1weGApO1xuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gb2Zmc2V0JCQxO1xuICAgIH1cbiAgICBzZXRaSW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRDb250YWluZXJTdHlsZSgnei1pbmRleCcsIFN0cmluZyh0aGlzLmRvbVNlcnZpY2UuekluZGV4KHRoaXMuYW5jaG9yLCB0aGlzLmNvbnRhaW5lcikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBvc2l0aW9uKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZmxpcCwgb2Zmc2V0OiBvZmZzZXQkJDEgfSA9IHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRPZmZzZXQgfHwgaXNEaWZmZXJlbnRPZmZzZXQodGhpcy5jdXJyZW50T2Zmc2V0LCBvZmZzZXQkJDEpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSBvZmZzZXQkJDE7XG4gICAgICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMucG9zaXRpb25DaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZS5lbWl0KHsgb2Zmc2V0OiBvZmZzZXQkJDEsIGZsaXAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU2VydmljZS5wbGF5KHRoaXMuY29udGVudENvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB0aGlzLmFuaW1hdGUsIGZsaXApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplU2Vuc29yLmFjY2VwdFNpemUoKTtcbiAgICB9XG4gICAgcG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGFsaWduZWRPZmZzZXQgPSB0aGlzLl9hbGlnblNlcnZpY2UuYWxpZ25FbGVtZW50KHtcbiAgICAgICAgICAgIGFuY2hvcjogdGhpcy5hbmNob3IsXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogdGhpcy5hbmNob3JBbGlnbixcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgZWxlbWVudEFsaWduOiB0aGlzLnBvcHVwQWxpZ24sXG4gICAgICAgICAgICBtYXJnaW46IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogdGhpcy5wb3NpdGlvbk1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblNlcnZpY2UucG9zaXRpb25FbGVtZW50KHtcbiAgICAgICAgICAgIGFuY2hvcjogdGhpcy5hbmNob3IsXG4gICAgICAgICAgICBhbmNob3JBbGlnbjogdGhpcy5hbmNob3JBbGlnbixcbiAgICAgICAgICAgIGNvbGxpc2lvbnM6IHRoaXMuY29sbGlzaW9uLFxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uOiBhbGlnbmVkT2Zmc2V0LFxuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICBlbGVtZW50QWxpZ246IHRoaXMucG9wdXBBbGlnbixcbiAgICAgICAgICAgIG1hcmdpbjogdGhpcy5tYXJnaW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKGlzSW5WaWV3UG9ydCkge1xuICAgICAgICBjb25zdCBoYXNMZWF2ZU9ic2VydmVycyA9IGhhc09ic2VydmVycyh0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUpO1xuICAgICAgICBpZiAoaXNJblZpZXdQb3J0IHx8ICFoYXNMZWF2ZU9ic2VydmVycykge1xuICAgICAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzTGVhdmVPYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclZpZXdwb3J0TGVhdmUuZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weUZvbnRTdHlsZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmNob3IgfHwgIXRoaXMuY29weUFuY2hvclN0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tU2VydmljZS5nZXRGb250U3R5bGVzKHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgLmZvckVhY2gocyA9PiB0aGlzLnNldENvbnRhaW5lclN0eWxlKHMua2V5LCBzLnZhbHVlKSk7XG4gICAgfVxuICAgIHVwZGF0ZUZpeGVkQ2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMucG9zaXRpb25Nb2RlID09PSAnZml4ZWQnID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyW2FjdGlvbl0odGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgQU5JTUFUSU9OX0NPTlRBSU5FUl9GSVhFRCk7XG4gICAgfVxuICAgIHNldENvbnRhaW5lclN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVSZXBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXBvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblBvcHVwQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kby1wb3B1cCcsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQWxpZ25TZXJ2aWNlLCBBbmltYXRpb25TZXJ2aWNlLCBET01TZXJ2aWNlLCBQb3NpdGlvblNlcnZpY2UsIFJlc2l6ZVNlcnZpY2UsIFNjcm9sbGFibGVTZXJ2aWNlXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXBvcHVwJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiay1wb3B1cFwiIFtuZ0NsYXNzXT1cInBvcHVwQ2xhc3NcIiAjY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbnRlbnRcIiBbbmdJZl09XCJjb250ZW50XCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yIFtyYXRlTGltaXRdPVwiMTAwXCIgKHJlc2l6ZSk9XCJvblJlc2l6ZSgpXCI+XG4gICAgICAgICAgICA8L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgICAgIDwvZGl2PlxuICAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBvcHVwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogQWxpZ25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBET01TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBQb3NpdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlc2l6ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNjcm9sbGFibGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBBbmltYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9XG5dO1xuUG9wdXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgYW5pbWF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYW5jaG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmNob3JBbGlnbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sbGlzaW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3B1cEFsaWduOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb3B5QW5jaG9yU3R5bGVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3B1cENsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3NpdGlvbk1vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG9mZnNldDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWFyZ2luOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbmNob3JWaWV3cG9ydExlYXZlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY2xvc2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBvcGVuOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcG9zaXRpb25DaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjb250ZW50Q29udGFpbmVyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnY29udGFpbmVyJyxdIH1dLFxuICAgIHJlc2l6ZVNlbnNvcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbUmVzaXplU2Vuc29yQ29tcG9uZW50LF0gfV1cbn07XG5cbmNvbnN0IHJlbW92ZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxufTtcbi8qKlxuICogVXNlZCB0byBpbmplY3QgdGhlIFBvcHVwIGNvbnRhaW5lci4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZmlyc3Qgcm9vdCBjb21wb25lbnQgb2ZcbiAqIHRoZSBhcHBsaWNhdGlvbiBpcyB1c2VkLlxuICpcbiAqID4gVGhlIGBQT1BVUF9DT05UQUlORVJgIGNhbiBiZSB1c2VkIG9ubHkgd2l0aCB0aGUgW2BQb3B1cFNlcnZpY2VgXSh7JSBzbHVnIHNlcnZpY2VfcG9wdXAgJX0pIGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFBvcHVwIG1vZHVsZVxuICogaW1wb3J0IHsgUG9wdXBNb2R1bGUsIFBPUFVQX0NPTlRBSU5FUiB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IEVsZW1lbnRSZWYsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgUG9wdXBNb2R1bGVdLCAvLyBpbXBvcnQgUG9wdXAgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBwcm92aWRlcnM6IFt7XG4gKiAgICAgICBwcm92aWRlOiBQT1BVUF9DT05UQUlORVIsXG4gKiAgICAgICB1c2VGYWN0b3J5OiAoKSA9PiB7XG4gKiAgICAgICAgICAvL3JldHVybiB0aGUgY29udGFpbmVyIEVsZW1lbnRSZWYsIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGluamVjdGVkXG4gKiAgICAgICAgICByZXR1cm4geyBuYXRpdmVFbGVtZW50OiBkb2N1bWVudC5ib2R5IH0gYXMgRWxlbWVudFJlZjtcbiAqICAgICAgIH1cbiAqICAgICB9XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICogYGBgXG4gKi9cbmNvbnN0IFBPUFVQX0NPTlRBSU5FUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignUG9wdXAgQ29udGFpbmVyJyk7XG4vKipcbiAqIEEgc2VydmljZSBmb3Igb3BlbmluZyBQb3B1cCBjb21wb25lbnRzIGR5bmFtaWNhbGx5XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNlcnZpY2VfcG9wdXAgJX0pKS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUG9wdXBTZXJ2aWNlXG4gKi9cbmNsYXNzIFBvcHVwU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb25SZWYsIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgaW5qZWN0b3IsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uUmVmID0gYXBwbGljYXRpb25SZWY7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByb290IHZpZXcgY29udGFpbmVyIGludG8gd2hpY2ggdGhlIGNvbXBvbmVudCB3aWxsIGJlIGluamVjdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxuICAgICAqL1xuICAgIGdldCByb290Vmlld0NvbnRhaW5lcigpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzQuMC54L3BhY2thZ2VzL2NvcmUvc3JjL2FwcGxpY2F0aW9uX3JlZi50cyNMNTcxXG4gICAgICAgIGNvbnN0IHJvb3RDb21wb25lbnRzID0gdGhpcy5hcHBsaWNhdGlvblJlZi5jb21wb25lbnRzIHx8IFtdO1xuICAgICAgICBpZiAocm9vdENvbXBvbmVudHNbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiByb290Q29tcG9uZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgICAgICAgVmlldyBDb250YWluZXIgbm90IGZvdW5kISBJbmplY3QgdGhlIFBPUFVQX0NPTlRBSU5FUiBvciBkZWZpbmUgYSBzcGVjaWZpYyBWaWV3Q29udGFpbmVyUmVmIHZpYSB0aGUgYXBwZW5kVG8gb3B0aW9uLlxuICAgICAgICAgICAgU2VlIGh0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL3BvcHVwL2FwaS9QT1BVUF9DT05UQUlORVIvIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIGApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIEhUTUwgZWxlbWVudCBvZiB0aGUgcm9vdCBjb21wb25lbnQgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCByb290Vmlld0NvbnRhaW5lck5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lciA/IHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLmdldENvbXBvbmVudFJvb3ROb2RlKHRoaXMucm9vdFZpZXdDb250YWluZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIFBvcHVwIGNvbXBvbmVudC4gQ3JlYXRlZCBQb3B1cHMgYXJlIG1vdW50ZWRcbiAgICAgKiBpbiB0aGUgRE9NIGRpcmVjdGx5IGluIHRoZSByb290IGFwcGxpY2F0aW9uIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9wdXBTZXR0aW5nc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHdoaWNoIGRlZmluZSB0aGUgUG9wdXAuXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxQb3B1cENvbXBvbmVudD59IC0gQSByZWZlcmVuY2UgdG8gdGhlIFBvcHVwIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICA8bmctdGVtcGxhdGUgI3RlbXBsYXRlPlxuICAgICAqICAgICAgUG9wdXAgY29udGVudFxuICAgICAqICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqICAgICA8YnV0dG9uICNhbmNob3Iga2VuZG9CdXR0b24gKGNsaWNrKT1cIm9wZW4oYW5jaG9yLCB0ZW1wbGF0ZSlcIj5PcGVuPC9idXR0b24+XG4gICAgICogICBgXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICAgcHVibGljIHBvcHVwUmVmOiBQb3B1cFJlZjtcbiAgICAgKlxuICAgICAqICAgICBjb25zdHJ1Y3RvciggcHJpdmF0ZSBwb3B1cFNlcnZpY2U6IFBvcHVwU2VydmljZSApIHt9XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIG9wZW4oYW5jaG9yOiBFbGVtZW50UmVmLCB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pik6IHZvaWQge1xuICAgICAqICAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgKiAgICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAqICAgICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gbnVsbDtcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAqICAgICAgICAgfVxuICAgICAqXG4gICAgICogICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3Blbih7XG4gICAgICogICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAqICAgICAgICAgICBjb250ZW50OiB0ZW1wbGF0ZVxuICAgICAqICAgICAgICAgfSk7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb3BlbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBjb21wb25lbnQsIG5vZGVzIH0gPSB0aGlzLmNvbnRlbnRGcm9tKG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgIGNvbnN0IHBvcHVwQ29tcG9uZW50UmVmID0gdGhpcy5hcHBlbmRQb3B1cChub2Rlcywgb3B0aW9ucy5hcHBlbmRUbyk7XG4gICAgICAgIGNvbnN0IHBvcHVwSW5zdGFuY2UgPSBwb3B1cENvbXBvbmVudFJlZi5pbnN0YW5jZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0Q29tcG9uZW50SW5wdXRzKHBvcHVwQ29tcG9uZW50UmVmLCBvcHRpb25zKTtcbiAgICAgICAgcG9wdXBDb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcHVwRWxlbWVudCA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUocG9wdXBDb21wb25lbnRSZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcHVwQ29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAvLyBBbmd1bGFyIHdpbGwgbm90IHJlbW92ZSB0aGUgZWxlbWVudCB1bmxlc3MgdGhlIGNoYW5nZSBkZXRlY3Rpb24gaXMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChwb3B1cEVsZW1lbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIHBvcHVwOiBwb3B1cENvbXBvbmVudFJlZixcbiAgICAgICAgICAgIHBvcHVwQW5jaG9yVmlld3BvcnRMZWF2ZTogcG9wdXBJbnN0YW5jZS5hbmNob3JWaWV3cG9ydExlYXZlLFxuICAgICAgICAgICAgcG9wdXBDbG9zZTogcG9wdXBJbnN0YW5jZS5jbG9zZSxcbiAgICAgICAgICAgIHBvcHVwRWxlbWVudDogcG9wdXBFbGVtZW50LFxuICAgICAgICAgICAgcG9wdXBPcGVuOiBwb3B1cEluc3RhbmNlLm9wZW4sXG4gICAgICAgICAgICBwb3B1cFBvc2l0aW9uQ2hhbmdlOiBwb3B1cEluc3RhbmNlLnBvc2l0aW9uQ2hhbmdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZFBvcHVwKG5vZGVzLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcG9wdXBDb21wb25lbnRSZWYgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudChQb3B1cENvbXBvbmVudCwgbm9kZXMsIGNvbnRhaW5lcik7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RWaWV3Q29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmdldENvbXBvbmVudFJvb3ROb2RlKHBvcHVwQ29tcG9uZW50UmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcHVwQ29tcG9uZW50UmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBIVE1MIGVsZW1lbnQgZm9yIGEgY29tcG9uZW50IHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50UmVmPGFueT59IGNvbXBvbmVudFJlZlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRSb290Tm9kZShjb21wb25lbnRSZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgQ29tcG9uZW50RmFjdG9yeWAgaW5zdGFuY2UgYnkgaXRzIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGNvbXBvbmVudENsYXNzXG4gICAgICogQHBhcmFtIHsqfSBub2Rlc1xuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudENsYXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRDbGFzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb25lbnQgcmVmZXJlbmNlIGZyb20gYSBgQ29tcG9uZW50YCB0eXBlIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBjb21wb25lbnRDbGFzc1xuICAgICAqIEBwYXJhbSB7Kn0gbm9kZXNcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XG4gICAgICovXG4gICAgY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudENsYXNzLCBub2RlcywgY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldENvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50Q2xhc3MpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5LCB1bmRlZmluZWQsIHRoaXMuaW5qZWN0b3IsIG5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IsIG5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25SZWYuYXR0YWNoVmlldyhjb21wb25lbnQuaG9zdFZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0cyB0aGUgaW5wdXRzIG9uIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudFJlZjxhbnk+fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XG4gICAgICovXG4gICAgcHJvamVjdENvbXBvbmVudElucHV0cyhjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3B0aW9ucylcbiAgICAgICAgICAgIC5maWx0ZXIocHJvcCA9PiBwcm9wICE9PSAnY29udGVudCcgfHwgb3B0aW9ucy5jb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWYpXG4gICAgICAgICAgICAubWFwKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnQuaW5zdGFuY2VbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29tcG9uZW50IGFuZCB0aGUgbm9kZXMgdG8gYXBwZW5kIGZyb20gdGhlIGBjb250ZW50YCBvcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIGNvbnRlbnRGcm9tKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCFjb250ZW50IHx8IGNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50OiBudWxsLCBub2RlczogW1tdXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY3JlYXRlQ29tcG9uZW50KGNvbnRlbnQpO1xuICAgICAgICBjb25zdCBub2RlcyA9IGNvbXBvbmVudCA/IFtjb21wb25lbnQubG9jYXRpb24ubmF0aXZlRWxlbWVudF0gOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgbm9kZXM6IFtcbiAgICAgICAgICAgICAgICBub2RlcyAvLyA8bmctY29udGVudD5cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG59XG5Qb3B1cFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblBvcHVwU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEFwcGxpY2F0aW9uUmVmIH0sXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgfSxcbiAgICB7IHR5cGU6IEluamVjdG9yIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQT1BVUF9DT05UQUlORVIsXSB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbmNvbnN0IFBPUFVQX0RJUkVDVElWRVMgPSBbUG9wdXBDb21wb25lbnRdO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgUG9wdXAgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHMtbm8tcnVuXG4gKiAvLyBJbXBvcnQgdGhlIFBvcHVwIG1vZHVsZVxuICogaW1wb3J0IHsgUG9wdXBNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFBvcHVwTW9kdWxlXSwgLy8gaW1wb3J0IFBvcHVwIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgUG9wdXBNb2R1bGUge1xufVxuUG9wdXBNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1BPUFVQX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1BPUFVQX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtQT1BVUF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGVdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1BvcHVwU2VydmljZV1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBBbGlnblNlcnZpY2UsIEFuaW1hdGlvblNlcnZpY2UsIERPTVNlcnZpY2UsIFBvc2l0aW9uU2VydmljZSwgUmVzaXplU2VydmljZSwgU2Nyb2xsYWJsZVNlcnZpY2UsIFBvcHVwU2VydmljZSwgUE9QVVBfQ09OVEFJTkVSLCBQb3B1cENvbXBvbmVudCwgUG9wdXBNb2R1bGUsIFNDQUxFIH07XG4iXX0=