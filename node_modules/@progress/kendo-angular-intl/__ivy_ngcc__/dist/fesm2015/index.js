/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Injectable, LOCALE_ID, defineInjectable, inject, Inject, Pipe, NgModule } from '@angular/core';
import { dateFormatNames, dateFieldName, firstDay, format, formatDate, formatNumber, load, numberSymbols, parseDate, parseNumber, splitDateFormat, toString, weekendRange, setData, localeInfo } from '@telerik/kendo-intl';

import * as ɵngcc0 from '@angular/core';
const DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';
/**
 * @hidden
 */
const errorSolutions = {
    'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,
    'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,
    'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,
    'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,
    'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,
    'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,
    'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,
    'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,
    'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`
};

function formatMessage(error) {
    const message = error.message;
    const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];
    return errorSolution ? `${message} ${errorSolution}` : message;
}
function intlMethod(fn) {
    return function (...values) {
        try {
            return fn.apply(null, values);
        }
        catch (error) {
            error.message = formatMessage(error);
            throw error;
        }
    };
}
/**
 * @hidden
 */
const dateFormatNames$1 = intlMethod(dateFormatNames);
/**
 * @hidden
 */
const dateFieldName$1 = intlMethod(dateFieldName);
/**
 * @hidden
 */
const firstDay$1 = intlMethod(firstDay);
/**
 * @hidden
 */
const format$1 = intlMethod(format);
/**
 * @hidden
 */
const formatDate$1 = intlMethod(formatDate);
/**
 * @hidden
 */
const formatNumber$1 = intlMethod(formatNumber);
/**
 * @hidden
 */
const load$1 = intlMethod(load);
/**
 * @hidden
 */
const numberSymbols$1 = intlMethod(numberSymbols);
/**
 * @hidden
 */
const parseDate$1 = intlMethod(parseDate);
/**
 * @hidden
 */
const parseNumber$1 = intlMethod(parseNumber);
/**
 * @hidden
 */
const splitDateFormat$1 = intlMethod(splitDateFormat);
/**
 * @hidden
 */
const toString$1 = intlMethod(toString);
/**
 * @hidden
 */
const weekendRange$1 = intlMethod(weekendRange);
/**
 * Sets a pre-built locale.
 *
 * @params data - The pre-built locale data.
 */
const setData$1 = (data) => setData(data);
/**
 * Retrieves the locale data for the specified locale.
 *
 * @params locale - The locale id.
 * @returns data - The locale data.
 */
const localeData = (locale) => {
    try {
        return localeInfo(locale);
    }
    catch (error) {
        error.message = formatMessage(error);
        throw error;
    }
};

const LOCALE_REGEX = /_/g;
/**
 * @hidden
 */
function cldrServiceFactory(localeId) {
    return new CldrIntlService(localeId);
}
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
class IntlService {
    constructor() {
        /**
         * @hidden
         */
        this.changes = new EventEmitter();
    }
    /**
     * Notifies that the service was changed.
     */
    notify() {
        this.changes.emit();
    }
}
IntlService.ɵfac = function IntlService_Factory(t) { return new (t || IntlService)(); };
IntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntlService, factory: function IntlService_Factory(t) { var r = null; if (t) {
        r = new t();
    }
    else {
        r = cldrServiceFactory(ɵngcc0.ɵɵinject(LOCALE_ID));
    } return r; }, providedIn: 'root' });
IntlService.ngInjectableDef = defineInjectable({ factory: function IntlService_Factory() { return cldrServiceFactory(inject(LOCALE_ID)); }, token: IntlService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
                useFactory: cldrServiceFactory,
                deps: [LOCALE_ID]
            }]
    }], function () { return []; }, null); })();
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
class CldrIntlService extends IntlService {
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId) {
        super();
        this.localeId = localeId;
    }
    /**
     * Gets or sets the current locale ID.
     */
    get localeId() {
        return this.locale;
    }
    set localeId(value) {
        // Angular locales use underscore, for example, en_US
        // while IETF BCP-47 specifies a dash.
        // https://tools.ietf.org/html/bcp47
        const locale = value.replace(LOCALE_REGEX, '-');
        if (locale !== this.locale) {
            this.locale = locale;
            this.notify();
        }
    }
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format$$1, ...values) {
        return format$1(format$$1, values, this.localeId);
    }
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value, format$$1, localeId) {
        return toString$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value, format$$1, localeId) {
        return formatDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value, format$$1, localeId) {
        return parseDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value, format$$1, localeId) {
        return parseNumber$1(value, localeId || this.localeId, format$$1);
    }
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value, format$$1, localeId) {
        return formatNumber$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options, localeId) {
        return dateFieldName$1(options, localeId || this.localeId);
    }
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options, localeId) {
        return dateFormatNames$1(localeId || this.localeId, options);
    }
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format$$1, localeId) {
        return splitDateFormat$1(format$$1, localeId || this.localeId);
    }
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId) {
        return numberSymbols$1(localeId || this.localeId);
    }
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId) {
        return firstDay$1(localeId || this.localeId);
    }
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId) {
        return weekendRange$1(localeId || this.localeId);
    }
}
CldrIntlService.ɵfac = function CldrIntlService_Factory(t) { return new (t || CldrIntlService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
CldrIntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CldrIntlService, factory: CldrIntlService.ɵfac });
/** @nocollapse */
CldrIntlService.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CldrIntlService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();

const isNumeric = (value) => !isNaN(value - parseFloat(value));
const ɵ0 = isNumeric;
/**
 * Formats a date value to a string based on the requested format.
 * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 * <ul>
 *    <li>{{date | kendoDate }}</li>
 *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>
 *    <li>{{stringDate | kendoDate: 'G' }}</li>
 * </ul>
 * ```
 */
class DatePipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.
     * @return - The formatted date.
     */
    transform(value, format$$1 = "", localeId) {
        value = this.normalize(value);
        if (value) {
            return this.intlService.formatDate(value, format$$1, localeId);
        }
        return value;
    }
    normalize(value) {
        if (value && typeof value === 'string') {
            value = this.intlService.parseDate(value);
        }
        else if (value && isNumeric(value)) {
            value = new Date(parseFloat(value));
        }
        return value;
    }
}
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
DatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoDate", type: DatePipe, pure: true });
/** @nocollapse */
DatePipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
                name: 'kendoDate'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();

/**
 * Formats a number value to a string based on the requested format.
 * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 *   <ul>
 *     <li>{{decimal | kendoNumber:'c' }}</li>
 *     <li>{{stringNumber | kendoNumber:'p' }}</li>
 *     <li>{{int | kendoNumber:'##.00' }}</li>
 *  </ul>
 * ```
 */
class NumberPipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Number` object into a string based on the specified format.
     * If no format is provided, the value is formatted as decimal number using the
     * [`"n"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.
     *
     * @param value - The numer that will be formatted.
     * @param format - The format string or options.
     * @param localeId - (Optional) The locale ID that will be used in place of the default one.
     * @return - The formatted number.
     */
    transform(value, format$$1, localeId) {
        if (typeof value === 'string') {
            value = this.intlService.parseNumber(value);
        }
        if (value !== null && value !== undefined) {
            return this.intlService.formatNumber(value, format$$1, localeId);
        }
        return value;
    }
}
NumberPipe.ɵfac = function NumberPipe_Factory(t) { return new (t || NumberPipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
NumberPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoNumber", type: NumberPipe, pure: true });
/** @nocollapse */
NumberPipe.ctorParameters = () => [
    { type: IntlService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberPipe, [{
        type: Pipe,
        args: [{
                name: 'kendoNumber'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();

const pipes = [
    DatePipe,
    NumberPipe
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)
 * definition for the Intl services.
 */
class IntlModule {
}
IntlModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntlModule });
IntlModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntlModule_Factory(t) { return new (t || IntlModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntlModule, { declarations: [DatePipe, NumberPipe], exports: [DatePipe, NumberPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlModule, [{
        type: NgModule,
        args: [{
                declarations: [pipes],
                exports: [pipes]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { cldrServiceFactory, IntlService, CldrIntlService, DatePipe, ɵ0, NumberPipe, IntlModule, dateFormatNames$1 as dateFormatNames, dateFieldName$1 as dateFieldName, firstDay$1 as firstDay, format$1 as format, formatDate$1 as formatDate, formatNumber$1 as formatNumber, load$1 as load, numberSymbols$1 as numberSymbols, parseDate$1 as parseDate, parseNumber$1 as parseNumber, splitDateFormat$1 as splitDateFormat, toString$1 as toString, weekendRange$1 as weekendRange, setData$1 as setData, localeData };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5Q0FPRTtBQUNGOzs7Ozs7OztnREFBc0w7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0ZBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O3FFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEZBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O3FFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgTE9DQUxFX0lELCBkZWZpbmVJbmplY3RhYmxlLCBpbmplY3QsIEluamVjdCwgUGlwZSwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRhdGVGb3JtYXROYW1lcywgZGF0ZUZpZWxkTmFtZSwgZmlyc3REYXksIGZvcm1hdCwgZm9ybWF0RGF0ZSwgZm9ybWF0TnVtYmVyLCBsb2FkLCBudW1iZXJTeW1ib2xzLCBwYXJzZURhdGUsIHBhcnNlTnVtYmVyLCBzcGxpdERhdGVGb3JtYXQsIHRvU3RyaW5nLCB3ZWVrZW5kUmFuZ2UsIHNldERhdGEsIGxvY2FsZUluZm8gfSBmcm9tICdAdGVsZXJpay9rZW5kby1pbnRsJztcblxuY29uc3QgRE9DU19VUkwgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvaW50ZXJuYXRpb25hbGl6YXRpb24vdHJvdWJsZXNob290aW5nLyc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXJyb3JTb2x1dGlvbnMgPSB7XG4gICAgJ05vQ3VycmVuY3knOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeWAsXG4gICAgJ05vQ3VycmVuY3lEaXNwbGF5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tY3VycmVuY3ktZGlzcGxheWAsXG4gICAgJ05vQ3VycmVuY3lSZWdpb24nOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeS1yZWdpb25gLFxuICAgICdOb0RhdGVGaWVsZE5hbWVzJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tZGF0ZS1maWxlZC1uYW1lc2AsXG4gICAgJ05vRmlyc3REYXknOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1maXJzdC1kYXlgLFxuICAgICdOb0dNVEluZm8nOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1nbXQtaW5mb2AsXG4gICAgJ05vTG9jYWxlJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tbG9jYWxlYCxcbiAgICAnTm9WYWxpZEN1cnJlbmN5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tdmFsaWQtY3VycmVuY3lgLFxuICAgICdOb1dlZWtEYXRhJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8td2Vlay1kYXRhYFxufTtcblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGNvbnN0IGVycm9yU29sdXRpb24gPSBlcnJvclNvbHV0aW9uc1tPYmplY3Qua2V5cyhlcnJvclNvbHV0aW9ucykuZmlsdGVyKGtleSA9PiBtZXNzYWdlLmluZGV4T2Yoa2V5KSA9PT0gMClbMF1dO1xuICAgIHJldHVybiBlcnJvclNvbHV0aW9uID8gYCR7bWVzc2FnZX0gJHtlcnJvclNvbHV0aW9ufWAgOiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gaW50bE1ldGhvZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4udmFsdWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRlRm9ybWF0TmFtZXMkMSA9IGludGxNZXRob2QoZGF0ZUZvcm1hdE5hbWVzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRlRmllbGROYW1lJDEgPSBpbnRsTWV0aG9kKGRhdGVGaWVsZE5hbWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpcnN0RGF5JDEgPSBpbnRsTWV0aG9kKGZpcnN0RGF5KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXQkMSA9IGludGxNZXRob2QoZm9ybWF0KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXREYXRlJDEgPSBpbnRsTWV0aG9kKGZvcm1hdERhdGUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdE51bWJlciQxID0gaW50bE1ldGhvZChmb3JtYXROdW1iZXIpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxvYWQkMSA9IGludGxNZXRob2QobG9hZCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbnVtYmVyU3ltYm9scyQxID0gaW50bE1ldGhvZChudW1iZXJTeW1ib2xzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYXJzZURhdGUkMSA9IGludGxNZXRob2QocGFyc2VEYXRlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYXJzZU51bWJlciQxID0gaW50bE1ldGhvZChwYXJzZU51bWJlcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3BsaXREYXRlRm9ybWF0JDEgPSBpbnRsTWV0aG9kKHNwbGl0RGF0ZUZvcm1hdCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9TdHJpbmckMSA9IGludGxNZXRob2QodG9TdHJpbmcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHdlZWtlbmRSYW5nZSQxID0gaW50bE1ldGhvZCh3ZWVrZW5kUmFuZ2UpO1xuLyoqXG4gKiBTZXRzIGEgcHJlLWJ1aWx0IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW1zIGRhdGEgLSBUaGUgcHJlLWJ1aWx0IGxvY2FsZSBkYXRhLlxuICovXG5jb25zdCBzZXREYXRhJDEgPSAoZGF0YSkgPT4gc2V0RGF0YShkYXRhKTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBsb2NhbGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gKlxuICogQHBhcmFtcyBsb2NhbGUgLSBUaGUgbG9jYWxlIGlkLlxuICogQHJldHVybnMgZGF0YSAtIFRoZSBsb2NhbGUgZGF0YS5cbiAqL1xuY29uc3QgbG9jYWxlRGF0YSA9IChsb2NhbGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbG9jYWxlSW5mbyhsb2NhbGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuXG5jb25zdCBMT0NBTEVfUkVHRVggPSAvXy9nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNsZHJTZXJ2aWNlRmFjdG9yeShsb2NhbGVJZCkge1xuICAgIHJldHVybiBuZXcgQ2xkckludGxTZXJ2aWNlKGxvY2FsZUlkKTtcbn1cbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IGltcGxlbWVudHNcbiAqIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIG1ldGhvZHNcbiAqIGZvciB0aGUgY3VycmVudCBsb2NhbGUuXG4gKi9cbmNsYXNzIEludGxTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhhdCB0aGUgc2VydmljZSB3YXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KCk7XG4gICAgfVxufVxuSW50bFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNsZHJTZXJ2aWNlRmFjdG9yeSxcbiAgICAgICAgICAgICAgICBkZXBzOiBbTE9DQUxFX0lEXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuSW50bFNlcnZpY2UubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIEludGxTZXJ2aWNlX0ZhY3RvcnkoKSB7IHJldHVybiBjbGRyU2VydmljZUZhY3RvcnkoaW5qZWN0KExPQ0FMRV9JRCkpOyB9LCB0b2tlbjogSW50bFNlcnZpY2UsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuLyoqXG4gKiBUaGUgSW50ZXJuYXRpb25hbGl6YXRpb24gc2VydmljZSBpbXBsZW1lbnRlZCBieSB1c2luZ1xuICogdGhlIENMRFIgRGF0YWJhc2UgdmlhIHRoZSBgQHRlbGVyaWsva2VuZG8taW50bGAgcGFja2FnZS5cbiAqL1xuY2xhc3MgQ2xkckludGxTZXJ2aWNlIGV4dGVuZHMgSW50bFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgSUQgb2YgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHBhcnRzIG9mIHRoZSBsb2NhbGUgSUQgY2FuIGJlIHNlcGFyYXRlZCBieSBlaXRoZXIgYF9gICh1bmRlcnNjb3JlKVxuICAgICAqIG9yIGAtYCAoZGFzaCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgZGVmYXVsdCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlSWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGVJZCA9IGxvY2FsZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqL1xuICAgIGdldCBsb2NhbGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuICAgIH1cbiAgICBzZXQgbG9jYWxlSWQodmFsdWUpIHtcbiAgICAgICAgLy8gQW5ndWxhciBsb2NhbGVzIHVzZSB1bmRlcnNjb3JlLCBmb3IgZXhhbXBsZSwgZW5fVVNcbiAgICAgICAgLy8gd2hpbGUgSUVURiBCQ1AtNDcgc3BlY2lmaWVzIGEgZGFzaC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2JjcDQ3XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHZhbHVlLnJlcGxhY2UoTE9DQUxFX1JFR0VYLCAnLScpO1xuICAgICAgICBpZiAobG9jYWxlICE9PSB0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMgc3VjaCBhc1xuICAgICAqIGBUb3RhbCBhbW91bnQgezA6Y31gLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBPbmUgb3IgbW9yZSB2YWx1ZXMgdG8gb3V0cHV0IGluIHRoZSBmb3JtYXQgc3RyaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCQkMSwgLi4udmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQkMShmb3JtYXQkJDEsIHZhbHVlcywgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byB1c2UuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNob3J0IGRhdGUgZm9ybWF0IGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBmb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgRGF0ZWAgb2JqZWN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZ3Mgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBkYXRlLlxuICAgICAqL1xuICAgIHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEYXRlJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgTnVtYmVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBudW1iZXIuXG4gICAgICovXG4gICAgcGFyc2VOdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyJDEodmFsdWUsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQsIGZvcm1hdCQkMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlciQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlIG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGB0eXBlYCB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGVyYWBcbiAgICAgKiAtIGB5ZWFyYFxuICAgICAqIC0gYHF1YXJ0ZXJgXG4gICAgICogLSBgbW9udGhgXG4gICAgICogLSBgd2Vla2BcbiAgICAgKiAtIGBkYXlgXG4gICAgICogLSBgZGF5cGVyaW9kYFxuICAgICAqIC0gYGhvdXJgXG4gICAgICogLSBgbWludXRlYFxuICAgICAqIC0gYHNlY29uZGBcbiAgICAgKiAtIGB6b25lYFxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBgbmFtZVR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgd2lkZWBcbiAgICAgKiAtIGBuYXJyb3dgXG4gICAgICogLSBgc2hvcnRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZmllbGQgbmFtZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZGF5IG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICogQHJldHVybnMgVGhlIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknIH0pOyAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknLCBuYW1lVHlwZTogJ3dpZGUnIH0pOyAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnc2hvcnQnIH0pOyAvL3JldHVybnMgJ21vLic7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAvL3JldHVybnMgJ21vbnRoJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkYXRlRmllbGROYW1lKG9wdGlvbnMsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBkYXRlRmllbGROYW1lJDEob3B0aW9ucywgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGJhc2VkIG9uIHNwZWNpZmljIGRhdGVGaWVsZE5hbWUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgdHlwZSB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgbW9udGhzYFxuICAgICAqIC0gYHF1YXJ0ZXJzYFxuICAgICAqIC0gYGVyYXNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKi9cbiAgICBkYXRlRm9ybWF0TmFtZXMob3B0aW9ucywgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXROYW1lcyQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIGRhdGUgZm9ybWF0IGludG8gb2JqZWN0cyBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggcGFydCBvZiB0aGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgVGhlIG9wdGlvbmFsIGxvY2FsZSBpZC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGBcImVuXCJgIGxvY2FsZSBpZCBpcyB1c2VkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlIGZvcm1hdCBwYXJ0cy5cbiAgICAgKi9cbiAgICBzcGxpdERhdGVGb3JtYXQoZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gc3BsaXREYXRlRm9ybWF0JDEoZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAgICAgKi9cbiAgICBudW1iZXJTeW1ib2xzKGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJTeW1ib2xzJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGRheSBpbmRleCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBmaXJzdERheShsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZmlyc3REYXkkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICB3ZWVrZW5kUmFuZ2UobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtlbmRSYW5nZSQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbn1cbkNsZHJJbnRsU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ2xkckludGxTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtMT0NBTEVfSUQsXSB9XSB9XG5dO1xuXG5jb25zdCBpc051bWVyaWMgPSAodmFsdWUpID0+ICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcbmNvbnN0IMm1MCA9IGlzTnVtZXJpYztcbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKiBUaGlzIHBpcGUgdXNlcyB0aGUgW0ludGxTZXJ2aWNlXSh7JSBzbHVnIGFwaV9pbnRsX2ludGxzZXJ2aWNlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgbmctdGVtcGxhdGUtbm8tcnVuXG4gKiA8dWw+XG4gKiAgICA8bGk+e3tkYXRlIHwga2VuZG9EYXRlIH19PC9saT5cbiAqICAgIDxsaT57e21pbGxpc2Vjb25kcyB8IGtlbmRvRGF0ZTogJ00vZGQveXl5JyB9fTwvbGk+XG4gKiAgICA8bGk+e3tzdHJpbmdEYXRlIHwga2VuZG9EYXRlOiAnRycgfX08L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICovXG5jbGFzcyBEYXRlUGlwZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGludGxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaW50bFNlcnZpY2UgPSBpbnRsU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgRGF0ZWAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBzaG9ydCBkYXRlIGZvcm1hdCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIChPcHRpb25hbCkgVGhlIElEIG9mIHRoZSBsb2NhbGUgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIGRhdGUuXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHZhbHVlLCBmb3JtYXQkJDEgPSBcIlwiLCBsb2NhbGVJZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRsU2VydmljZS5mb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmludGxTZXJ2aWNlLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgJiYgaXNOdW1lcmljKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbkRhdGVQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBQaXBlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdrZW5kb0RhdGUnXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRhdGVQaXBlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogSW50bFNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyIHZhbHVlIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICogVGhpcyBwaXBlIHVzZXMgdGhlIFtgSW50bFNlcnZpY2VgXSh7JSBzbHVnIGFwaV9pbnRsX2ludGxzZXJ2aWNlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgbmctdGVtcGxhdGUtbm8tcnVuXG4gKiAgIDx1bD5cbiAqICAgICA8bGk+e3tkZWNpbWFsIHwga2VuZG9OdW1iZXI6J2MnIH19PC9saT5cbiAqICAgICA8bGk+e3tzdHJpbmdOdW1iZXIgfCBrZW5kb051bWJlcjoncCcgfX08L2xpPlxuICogICAgIDxsaT57e2ludCB8IGtlbmRvTnVtYmVyOicjIy4wMCcgfX08L2xpPlxuICogIDwvdWw+XG4gKiBgYGBcbiAqL1xuY2xhc3MgTnVtYmVyUGlwZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGludGxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaW50bFNlcnZpY2UgPSBpbnRsU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgTnVtYmVyYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsIHRoZSB2YWx1ZSBpcyBmb3JtYXR0ZWQgYXMgZGVjaW1hbCBudW1iZXIgdXNpbmcgdGhlXG4gICAgICogW2BcIm5cImBdKGh0dHBzOi8vZ2l0aHViLmNvbS90ZWxlcmlrL2tlbmRvLWludGwvYmxvYi9tYXN0ZXIvZG9jcy9udW0tZm9ybWF0dGluZy9pbmRleC5tZCNzdGFuZGFyZCkgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWVyIHRoYXQgd2lsbCBiZSBmb3JtYXR0ZWQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gKE9wdGlvbmFsKSBUaGUgbG9jYWxlIElEIHRoYXQgd2lsbCBiZSB1c2VkIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW50bFNlcnZpY2UucGFyc2VOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRsU2VydmljZS5mb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5OdW1iZXJQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBQaXBlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdrZW5kb051bWJlcidcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTnVtYmVyUGlwZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEludGxTZXJ2aWNlIH1cbl07XG5cbmNvbnN0IHBpcGVzID0gW1xuICAgIERhdGVQaXBlLFxuICAgIE51bWJlclBpcGVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fWRvY3MvdHMvbGF0ZXN0L2d1aWRlL25nbW9kdWxlLmh0bWwpXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgSW50bCBzZXJ2aWNlcy5cbiAqL1xuY2xhc3MgSW50bE1vZHVsZSB7XG59XG5JbnRsTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtwaXBlc10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW3BpcGVzXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IGNsZHJTZXJ2aWNlRmFjdG9yeSwgSW50bFNlcnZpY2UsIENsZHJJbnRsU2VydmljZSwgRGF0ZVBpcGUsIMm1MCwgTnVtYmVyUGlwZSwgSW50bE1vZHVsZSwgZGF0ZUZvcm1hdE5hbWVzJDEgYXMgZGF0ZUZvcm1hdE5hbWVzLCBkYXRlRmllbGROYW1lJDEgYXMgZGF0ZUZpZWxkTmFtZSwgZmlyc3REYXkkMSBhcyBmaXJzdERheSwgZm9ybWF0JDEgYXMgZm9ybWF0LCBmb3JtYXREYXRlJDEgYXMgZm9ybWF0RGF0ZSwgZm9ybWF0TnVtYmVyJDEgYXMgZm9ybWF0TnVtYmVyLCBsb2FkJDEgYXMgbG9hZCwgbnVtYmVyU3ltYm9scyQxIGFzIG51bWJlclN5bWJvbHMsIHBhcnNlRGF0ZSQxIGFzIHBhcnNlRGF0ZSwgcGFyc2VOdW1iZXIkMSBhcyBwYXJzZU51bWJlciwgc3BsaXREYXRlRm9ybWF0JDEgYXMgc3BsaXREYXRlRm9ybWF0LCB0b1N0cmluZyQxIGFzIHRvU3RyaW5nLCB3ZWVrZW5kUmFuZ2UkMSBhcyB3ZWVrZW5kUmFuZ2UsIHNldERhdGEkMSBhcyBzZXREYXRhLCBsb2NhbGVEYXRhIH07XG4iXX0=