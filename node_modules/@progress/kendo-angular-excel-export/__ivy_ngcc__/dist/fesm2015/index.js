/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Input, ContentChildren, QueryList, Component, NgZone, Directive, TemplateRef, Optional, forwardRef, SkipSelf, Host, ContentChild, NgModule } from '@angular/core';
import { saveAs } from '@progress/kendo-file-saver';
import { IntlService, ExcelExporter, Workbook } from '@progress/kendo-ooxml';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
export * from '@progress/kendo-ooxml';
import { toString } from '@telerik/kendo-intl';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';

/* tslint:disable align */
/* tslint:disable:no-use-before-declare */
const compileTemplate = (templateRef, context, updateContext) => {
    let embeddedView = templateRef.createEmbeddedView(context);
    const result = (data) => {
        updateContext(context, data);
        embeddedView.detectChanges();
        return embeddedView.rootNodes.reduce((content, rootNode) => {
            return content + rootNode.textContent;
        }, '').trim();
    };
    result.destroy = () => {
        embeddedView.destroy();
        embeddedView = null;
    };
    return result;
};
const updateGroupHeaderContext = (context, data) => {
    context.$implicit = context.group = data;
    context.field = data.field;
    context.value = data.value;
    context.aggregates = data.aggregates;
};
const updateGroupFooterContext = (context, data) => {
    context.group = data.group;
    context.$implicit = context.aggregates = data;
};
const updateFooterContext = (context, data) => {
    context.aggregates = data.aggregates;
};
/**
 * @hidden
 */
const toExporterColumns = (sourceColumns) => {
    const exporterColumns = [];
    let columnIndex = 0;
    const addColumns = (columns, result, level) => {
        columns.forEach((column) => {
            if (column.level === level) {
                const exporterColumn = new ExporterColumn(column, columnIndex);
                result.push(exporterColumn);
                if (column.children && column.children.some(c => c !== column)) {
                    const children = exporterColumn.columns = [];
                    addColumns(column.children, children, level + 1);
                }
                else {
                    columnIndex++;
                }
            }
        });
    };
    addColumns(sourceColumns, exporterColumns, 0);
    return exporterColumns;
};
/**
 * @hidden
 */
const destroyColumns = (columns) => {
    if (columns) {
        columns.forEach(column => {
            column.destroy();
        });
    }
};
/**
 * @hidden
 */
class ExporterColumn {
    constructor(column, columnIndex) {
        this.title = column.title;
        this.field = column.field;
        this.hidden = column.hidden;
        this.locked = column.locked;
        this.width = column.width;
        this.headerCellOptions = column.headerCellOptions;
        this.cellOptions = column.cellOptions;
        this.groupHeaderCellOptions = column.groupHeaderCellOptions;
        this.groupFooterCellOptions = column.groupFooterCellOptions;
        this.footerCellOptions = column.footerCellOptions;
        if (column.footerTemplate) {
            this.footerTemplate = compileTemplate(column.footerTemplate.templateRef, {
                $implicit: column,
                column: column,
                columnIndex: columnIndex
            }, updateFooterContext);
        }
        if (column.groupFooterTemplate) {
            this.groupFooterTemplate = compileTemplate(column.groupFooterTemplate.templateRef, {
                column: column,
                field: column.field
            }, updateGroupFooterContext);
        }
        if (column.groupHeaderTemplate) {
            this.groupHeaderTemplate = compileTemplate(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);
        }
        if (column.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate = compileTemplate(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);
        }
    }
    destroy() {
        if (this.footerTemplate) {
            this.footerTemplate.destroy();
        }
        if (this.groupFooterTemplate) {
            this.groupFooterTemplate.destroy();
        }
        if (this.groupHeaderTemplate) {
            this.groupHeaderTemplate.destroy();
        }
        if (this.groupHeaderColumnTemplate) {
            this.groupHeaderColumnTemplate.destroy();
        }
        destroyColumns(this.columns);
    }
}

IntlService.register({ toString });
/**
 *
 * @hidden
 */
const workbookOptions = (options) => {
    const columns = toExporterColumns(options.columns);
    const exporter = new ExcelExporter({
        columns: columns,
        data: options.data,
        filterable: options.filterable,
        groups: options.group,
        paddingCellOptions: options.paddingCellOptions,
        headerPaddingCellOptions: options.headerPaddingCellOptions,
        collapsible: options.collapsible,
        hierarchy: options.hierarchy,
        aggregates: options.aggregates
    });
    const result = exporter.workbook();
    result.creator = options.creator;
    result.date = options.date;
    result.rtl = options.rtl;
    destroyColumns(columns);
    return result;
};
/**
 * @hidden
 */
const toDataURL = (options) => {
    const workbook = new Workbook(options);
    return workbook.toDataURL();
};
/**
 * @hidden
 */
const isWorkbookOptions = (value) => {
    return value && value.sheets;
};

/**
 * @hidden
 */
class ColumnBase {
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * @hidden
     */
    get level() {
        return this.parent ? this.parent.level + 1 : 0;
    }
}
ColumnBase.ɵfac = function ColumnBase_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ColumnBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnBase, contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { title: "title", width: "width", locked: "locked", hidden: "hidden", headerCellOptions: "headerCellOptions" } });
ColumnBase.propDecorators = {
    title: [{ type: Input }],
    width: [{ type: Input }],
    locked: [{ type: Input }],
    hidden: [{ type: Input }],
    headerCellOptions: [{ type: Input }],
    children: [{ type: ContentChildren, args: [ColumnBase,] }]
};


// tslint:disable:max-line-length
/**
 * Represents the [Kendo UI Excel Export component for Angular]({% slug overview_excelexport %}).
 * Configures the settings for the Excel export of the Kendo UI Grid.
 */
class ExcelExportComponent {
    constructor(localization, zone) {
        this.localization = localization;
        this.zone = zone;
        /**
         * Specifies the name of the file that is exported to Excel.
         * @default "Export.xlsx"
         */
        this.fileName = 'Export.xlsx';
        /**
         * @hidden
         */
        this.columns = new QueryList();
        this.saveFile = this.saveFile.bind(this);
    }
    /**
     * Saves the data to Excel.
     *
     * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).
     */
    save(exportData) {
        this.toDataURL(exportData).then(this.saveFile);
    }
    /**
     * Based on the specified columns and data, returns
     * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})
     * ([see example]({% slug customrowsandcells_excelexport %})).
     *
     * @param exportData - The optional data to be exported.
     * @returns {WorkbookOptions} - The workbook options.
     */
    workbookOptions(exportData) {
        const currentData = this.getExportData(exportData);
        const options = workbookOptions({
            columns: this.columns,
            data: currentData.data,
            group: currentData.group,
            filterable: this.filterable,
            creator: this.creator,
            date: this.date,
            rtl: this.localization.rtl,
            paddingCellOptions: this.paddingCellOptions,
            headerPaddingCellOptions: this.headerPaddingCellOptions,
            collapsible: this.collapsible
        });
        return options;
    }
    /**
     * Returns a promise which will be resolved with the file data URI
     * ([see example]({% slug filesaving_excelexport %})).
     *
     * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.
     * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
     */
    toDataURL(exportData) {
        const options = isWorkbookOptions(exportData) ?
            exportData :
            this.workbookOptions(exportData);
        return this.zone.runOutsideAngular(() => toDataURL(options));
    }
    getExportData(exportData) {
        let result;
        if (exportData) {
            if (Array.isArray(exportData)) {
                result = {
                    data: exportData
                };
            }
            else {
                result = exportData;
            }
        }
        else {
            result = {
                data: this.data,
                group: this.group
            };
        }
        return result;
    }
    saveFile(dataURL) {
        saveAs(dataURL, this.fileName, {
            forceProxy: this.forceProxy,
            proxyURL: this.proxyURL
        });
    }
}
ExcelExportComponent.ɵfac = function ExcelExportComponent_Factory(t) { return new (t || ExcelExportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ExcelExportComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ExcelExportComponent, selectors: [["kendo-excelexport"]], contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColumnBase, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columns = _t);
    } }, inputs: { fileName: "fileName", filterable: "filterable", collapsible: "collapsible", creator: "creator", date: "date", forceProxy: "forceProxy", proxyURL: "proxyURL", data: "data", group: "group", paddingCellOptions: "paddingCellOptions", headerPaddingCellOptions: "headerPaddingCellOptions" }, exportAs: ["kendoExcelExport"], features: [ɵngcc0.ɵɵProvidersFeature([
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.excelexport'
            }
        ])], decls: 0, vars: 0, template: function ExcelExportComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ExcelExportComponent.ctorParameters = () => [
    { type: LocalizationService },
    { type: NgZone }
];
ExcelExportComponent.propDecorators = {
    fileName: [{ type: Input }],
    filterable: [{ type: Input }],
    collapsible: [{ type: Input }],
    creator: [{ type: Input }],
    date: [{ type: Input }],
    forceProxy: [{ type: Input }],
    proxyURL: [{ type: Input }],
    data: [{ type: Input }],
    group: [{ type: Input }],
    paddingCellOptions: [{ type: Input }],
    headerPaddingCellOptions: [{ type: Input }],
    columns: [{ type: ContentChildren, args: [ColumnBase, { descendants: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelExportComponent, [{
        type: Component,
        args: [{
                exportAs: 'kendoExcelExport',
                selector: 'kendo-excelexport',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.excelexport'
                    }
                ],
                template: ``
            }]
    }], function () { return [{ type: ɵngcc1.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { fileName: [{
            type: Input
        }], columns: [{
            type: ContentChildren,
            args: [ColumnBase, { descendants: true }]
        }], filterable: [{
            type: Input
        }], collapsible: [{
            type: Input
        }], creator: [{
            type: Input
        }], date: [{
            type: Input
        }], forceProxy: [{
            type: Input
        }], proxyURL: [{
            type: Input
        }], data: [{
            type: Input
        }], group: [{
            type: Input
        }], paddingCellOptions: [{
            type: Input
        }], headerPaddingCellOptions: [{
            type: Input
        }] }); })();

/**
 * Represents the group header cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-template)).
 * Enables you to customize the content of the group header item.
 */
class GroupHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) { return new (t || GroupHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderTemplate", ""]] });
/** @nocollapse */
GroupHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the group header column template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-header-column-template)).
 */
class GroupHeaderColumnTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) { return new (t || GroupHeaderColumnTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupHeaderColumnTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupHeaderColumnTemplateDirective, selectors: [["", "kendoExcelExportGroupHeaderColumnTemplate", ""]] });
/** @nocollapse */
GroupHeaderColumnTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupHeaderColumnTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupHeaderColumnTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the group footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-group-footer-template)).
 * Enables you to customize the group footer cell of the column.
 */
class GroupFooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) { return new (t || GroupFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
GroupFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: GroupFooterTemplateDirective, selectors: [["", "kendoExcelExportGroupFooterTemplate", ""]] });
/** @nocollapse */
GroupFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportGroupFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the footer cell template of the Excel Export column component
 * ([see example]({% slug columns_excel-export %}#toc-footer-template)).
 * Enables you to customize the footer cell of the column.
 */
class FooterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) { return new (t || FooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
FooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FooterTemplateDirective, selectors: [["", "kendoExcelExportFooterTemplate", ""]] });
/** @nocollapse */
FooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoExcelExportFooterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the columns of the Kendo UI Excel Export component for Angular.
 */
class ColumnComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
    }
}
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) { return new (t || ColumnComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnComponent, selectors: [["kendo-excelexport-column"]], contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, FooterTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
    } }, inputs: { field: "field", cellOptions: "cellOptions", groupHeaderCellOptions: "groupHeaderCellOptions", groupFooterCellOptions: "groupFooterCellOptions", footerCellOptions: "footerCellOptions" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnComponent.ctorParameters = () => [
    { type: ColumnBase, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
ColumnComponent.propDecorators = {
    field: [{ type: Input }],
    cellOptions: [{ type: Input }],
    groupHeaderCellOptions: [{ type: Input }],
    groupFooterCellOptions: [{ type: Input }],
    footerCellOptions: [{ type: Input }],
    groupHeaderTemplate: [{ type: ContentChild, args: [GroupHeaderTemplateDirective,] }],
    groupHeaderColumnTemplate: [{ type: ContentChild, args: [GroupHeaderColumnTemplateDirective,] }],
    groupFooterTemplate: [{ type: ContentChild, args: [GroupFooterTemplateDirective,] }],
    footerTemplate: [{ type: ContentChild, args: [FooterTemplateDirective,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, { field: [{
            type: Input
        }], cellOptions: [{
            type: Input
        }], groupHeaderCellOptions: [{
            type: Input
        }], groupFooterCellOptions: [{
            type: Input
        }], footerCellOptions: [{
            type: Input
        }], groupHeaderTemplate: [{
            type: ContentChild,
            args: [GroupHeaderTemplateDirective]
        }], groupHeaderColumnTemplate: [{
            type: ContentChild,
            args: [GroupHeaderColumnTemplateDirective]
        }], groupFooterTemplate: [{
            type: ContentChild,
            args: [GroupFooterTemplateDirective]
        }], footerTemplate: [{
            type: ContentChild,
            args: [FooterTemplateDirective]
        }] }); })();

/**
 * Represents the column group component of the Kendo UI Excel Export component.
 */
class ColumnGroupComponent extends ColumnBase {
    constructor(parent) {
        super(parent);
        this.parent = parent;
    }
}
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) { return new (t || ColumnGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ColumnBase, 13)); };
ColumnGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ColumnGroupComponent, selectors: [["kendo-excelexport-column-group"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ColumnBase,
                useExisting: forwardRef(() => ColumnGroupComponent) // tslint:disable-line:no-forward-ref
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
ColumnGroupComponent.ctorParameters = () => [
    { type: ColumnBase, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnGroupComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: ColumnBase,
                        useExisting: forwardRef(() => ColumnGroupComponent) // tslint:disable-line:no-forward-ref
                    }
                ],
                selector: 'kendo-excelexport-column-group',
                template: ``
            }]
    }], function () { return [{ type: ColumnBase, decorators: [{
                type: SkipSelf
            }, {
                type: Host
            }, {
                type: Optional
            }] }]; }, null); })();

const declarations = [
    ExcelExportComponent,
    ColumnComponent,
    ColumnGroupComponent,
    FooterTemplateDirective,
    GroupFooterTemplateDirective,
    GroupHeaderTemplateDirective,
    GroupHeaderColumnTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Excel Export component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the ExcelExportModule module
 * import { ExcelExportModule } from '@progress/kendo-angular-excel-export';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, ExcelExportModule], // import ExcelExportModule module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class ExcelExportModule {
}
ExcelExportModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ExcelExportModule });
ExcelExportModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ExcelExportModule_Factory(t) { return new (t || ExcelExportModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ExcelExportModule, { declarations: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective], exports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExcelExportModule, [{
        type: NgModule,
        args: [{
                declarations: [declarations],
                exports: [declarations]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { GroupHeaderColumnTemplateDirective, ExcelExportComponent, ExcelExportModule, ColumnBase, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, workbookOptions, toDataURL, isWorkbookOptions };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O21JQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O21IQWNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxTEFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b0pBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztpSkFZRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzSkFZRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBJbnB1dCwgQ29udGVudENoaWxkcmVuLCBRdWVyeUxpc3QsIENvbXBvbmVudCwgTmdab25lLCBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmLCBPcHRpb25hbCwgZm9yd2FyZFJlZiwgU2tpcFNlbGYsIEhvc3QsIENvbnRlbnRDaGlsZCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1maWxlLXNhdmVyJztcbmltcG9ydCB7IEludGxTZXJ2aWNlLCBFeGNlbEV4cG9ydGVyLCBXb3JrYm9vayB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1vb3htbCc7XG5leHBvcnQgKiBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tb294bWwnO1xuaW1wb3J0IHsgdG9TdHJpbmcgfSBmcm9tICdAdGVsZXJpay9rZW5kby1pbnRsJztcbmltcG9ydCB7IExvY2FsaXphdGlvblNlcnZpY2UsIEwxME5fUFJFRklYIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5cbi8qIHRzbGludDpkaXNhYmxlIGFsaWduICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby11c2UtYmVmb3JlLWRlY2xhcmUgKi9cbmNvbnN0IGNvbXBpbGVUZW1wbGF0ZSA9ICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgdXBkYXRlQ29udGV4dCkgPT4ge1xuICAgIGxldCBlbWJlZGRlZFZpZXcgPSB0ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dCk7XG4gICAgY29uc3QgcmVzdWx0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgdXBkYXRlQ29udGV4dChjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgZW1iZWRkZWRWaWV3LmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuIGVtYmVkZGVkVmlldy5yb290Tm9kZXMucmVkdWNlKChjb250ZW50LCByb290Tm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQgKyByb290Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgfSwgJycpLnRyaW0oKTtcbiAgICB9O1xuICAgIHJlc3VsdC5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICBlbWJlZGRlZFZpZXcuZGVzdHJveSgpO1xuICAgICAgICBlbWJlZGRlZFZpZXcgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuJGltcGxpY2l0ID0gY29udGV4dC5ncm91cCA9IGRhdGE7XG4gICAgY29udGV4dC5maWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgY29udGV4dC52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgY29udGV4dC5hZ2dyZWdhdGVzID0gZGF0YS5hZ2dyZWdhdGVzO1xufTtcbmNvbnN0IHVwZGF0ZUdyb3VwRm9vdGVyQ29udGV4dCA9IChjb250ZXh0LCBkYXRhKSA9PiB7XG4gICAgY29udGV4dC5ncm91cCA9IGRhdGEuZ3JvdXA7XG4gICAgY29udGV4dC4kaW1wbGljaXQgPSBjb250ZXh0LmFnZ3JlZ2F0ZXMgPSBkYXRhO1xufTtcbmNvbnN0IHVwZGF0ZUZvb3RlckNvbnRleHQgPSAoY29udGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnRleHQuYWdncmVnYXRlcyA9IGRhdGEuYWdncmVnYXRlcztcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9FeHBvcnRlckNvbHVtbnMgPSAoc291cmNlQ29sdW1ucykgPT4ge1xuICAgIGNvbnN0IGV4cG9ydGVyQ29sdW1ucyA9IFtdO1xuICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XG4gICAgY29uc3QgYWRkQ29sdW1ucyA9IChjb2x1bW5zLCByZXN1bHQsIGxldmVsKSA9PiB7XG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1uLmxldmVsID09PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVyQ29sdW1uID0gbmV3IEV4cG9ydGVyQ29sdW1uKGNvbHVtbiwgY29sdW1uSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cG9ydGVyQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmNoaWxkcmVuICYmIGNvbHVtbi5jaGlsZHJlbi5zb21lKGMgPT4gYyAhPT0gY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGV4cG9ydGVyQ29sdW1uLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29sdW1ucyhjb2x1bW4uY2hpbGRyZW4sIGNoaWxkcmVuLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYWRkQ29sdW1ucyhzb3VyY2VDb2x1bW5zLCBleHBvcnRlckNvbHVtbnMsIDApO1xuICAgIHJldHVybiBleHBvcnRlckNvbHVtbnM7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRlc3Ryb3lDb2x1bW5zID0gKGNvbHVtbnMpID0+IHtcbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbHVtbi5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgRXhwb3J0ZXJDb2x1bW4ge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbiwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdGhpcy50aXRsZSA9IGNvbHVtbi50aXRsZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGNvbHVtbi5maWVsZDtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBjb2x1bW4uaGlkZGVuO1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGNvbHVtbi5sb2NrZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBjb2x1bW4ud2lkdGg7XG4gICAgICAgIHRoaXMuaGVhZGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uaGVhZGVyQ2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2VsbE9wdGlvbnMgPSBjb2x1bW4uY2VsbE9wdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5ncm91cEhlYWRlckNlbGxPcHRpb25zO1xuICAgICAgICB0aGlzLmdyb3VwRm9vdGVyQ2VsbE9wdGlvbnMgPSBjb2x1bW4uZ3JvdXBGb290ZXJDZWxsT3B0aW9ucztcbiAgICAgICAgdGhpcy5mb290ZXJDZWxsT3B0aW9ucyA9IGNvbHVtbi5mb290ZXJDZWxsT3B0aW9ucztcbiAgICAgICAgaWYgKGNvbHVtbi5mb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb290ZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZm9vdGVyVGVtcGxhdGUudGVtcGxhdGVSZWYsIHtcbiAgICAgICAgICAgICAgICAkaW1wbGljaXQ6IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXhcbiAgICAgICAgICAgIH0sIHVwZGF0ZUZvb3RlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uZ3JvdXBGb290ZXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEZvb3RlclRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKGNvbHVtbi5ncm91cEZvb3RlclRlbXBsYXRlLnRlbXBsYXRlUmVmLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5maWVsZFxuICAgICAgICAgICAgfSwgdXBkYXRlR3JvdXBGb290ZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmdyb3VwSGVhZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZSA9IGNvbXBpbGVUZW1wbGF0ZShjb2x1bW4uZ3JvdXBIZWFkZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZiwge30sIHVwZGF0ZUdyb3VwSGVhZGVyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbi5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUgPSBjb21waWxlVGVtcGxhdGUoY29sdW1uLmdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGUudGVtcGxhdGVSZWYsIHt9LCB1cGRhdGVHcm91cEhlYWRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvb3RlclRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cEZvb3RlclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwRm9vdGVyVGVtcGxhdGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyb3VwSGVhZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBIZWFkZXJUZW1wbGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBIZWFkZXJDb2x1bW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cEhlYWRlckNvbHVtblRlbXBsYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95Q29sdW1ucyh0aGlzLmNvbHVtbnMpO1xuICAgIH1cbn1cblxuSW50bFNlcnZpY2UucmVnaXN0ZXIoeyB0b1N0cmluZyB9KTtcbi8qKlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgd29ya2Jvb2tPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb2x1bW5zID0gdG9FeHBvcnRlckNvbHVtbnMob3B0aW9ucy5jb2x1bW5zKTtcbiAgICBjb25zdCBleHBvcnRlciA9IG5ldyBFeGNlbEV4cG9ydGVyKHtcbiAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhLFxuICAgICAgICBmaWx0ZXJhYmxlOiBvcHRpb25zLmZpbHRlcmFibGUsXG4gICAgICAgIGdyb3Vwczogb3B0aW9ucy5ncm91cCxcbiAgICAgICAgcGFkZGluZ0NlbGxPcHRpb25zOiBvcHRpb25zLnBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zOiBvcHRpb25zLmhlYWRlclBhZGRpbmdDZWxsT3B0aW9ucyxcbiAgICAgICAgY29sbGFwc2libGU6IG9wdGlvbnMuY29sbGFwc2libGUsXG4gICAgICAgIGhpZXJhcmNoeTogb3B0aW9ucy5oaWVyYXJjaHksXG4gICAgICAgIGFnZ3JlZ2F0ZXM6IG9wdGlvbnMuYWdncmVnYXRlc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4cG9ydGVyLndvcmtib29rKCk7XG4gICAgcmVzdWx0LmNyZWF0b3IgPSBvcHRpb25zLmNyZWF0b3I7XG4gICAgcmVzdWx0LmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgcmVzdWx0LnJ0bCA9IG9wdGlvbnMucnRsO1xuICAgIGRlc3Ryb3lDb2x1bW5zKGNvbHVtbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRvRGF0YVVSTCA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgV29ya2Jvb2sob3B0aW9ucyk7XG4gICAgcmV0dXJuIHdvcmtib29rLnRvRGF0YVVSTCgpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1dvcmtib29rT3B0aW9ucyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5zaGVldHM7XG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sdW1uQmFzZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5sZXZlbCArIDEgOiAwO1xuICAgIH1cbn1cbkNvbHVtbkJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdpZHRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb2NrZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhpZGRlbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGVhZGVyQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtDb2x1bW5CYXNlLF0gfV1cbn07XG5cbi8vIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aFxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudCBmb3IgQW5ndWxhcl0oeyUgc2x1ZyBvdmVydmlld19leGNlbGV4cG9ydCAlfSkuXG4gKiBDb25maWd1cmVzIHRoZSBzZXR0aW5ncyBmb3IgdGhlIEV4Y2VsIGV4cG9ydCBvZiB0aGUgS2VuZG8gVUkgR3JpZC5cbiAqL1xuY2xhc3MgRXhjZWxFeHBvcnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsaXphdGlvbiwgem9uZSkge1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvbiA9IGxvY2FsaXphdGlvbjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0aGF0IGlzIGV4cG9ydGVkIHRvIEV4Y2VsLlxuICAgICAgICAgKiBAZGVmYXVsdCBcIkV4cG9ydC54bHN4XCJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnRXhwb3J0Lnhsc3gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICB0aGlzLnNhdmVGaWxlID0gdGhpcy5zYXZlRmlsZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgZGF0YSB0byBFeGNlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBvcnREYXRhIC0gQW4gb3B0aW9uYWwgcGFyYW1ldGVyLiBDYW4gYmUgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIGV4cG9ydGVkIG9yIFtgV29ya2Jvb2tPcHRpb25zYF0oeyUgc2x1ZyBhcGlfZXhjZWwtZXhwb3J0X3dvcmtib29rb3B0aW9ucyAlfSkuXG4gICAgICovXG4gICAgc2F2ZShleHBvcnREYXRhKSB7XG4gICAgICAgIHRoaXMudG9EYXRhVVJMKGV4cG9ydERhdGEpLnRoZW4odGhpcy5zYXZlRmlsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgY29sdW1ucyBhbmQgZGF0YSwgcmV0dXJuc1xuICAgICAqIFtgV29ya2Jvb2tPcHRpb25zYF0oeyUgc2x1ZyBhcGlfZXhjZWwtZXhwb3J0X3dvcmtib29rb3B0aW9ucyAlfSlcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGN1c3RvbXJvd3NhbmRjZWxsc19leGNlbGV4cG9ydCAlfSkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV4cG9ydERhdGEgLSBUaGUgb3B0aW9uYWwgZGF0YSB0byBiZSBleHBvcnRlZC5cbiAgICAgKiBAcmV0dXJucyB7V29ya2Jvb2tPcHRpb25zfSAtIFRoZSB3b3JrYm9vayBvcHRpb25zLlxuICAgICAqL1xuICAgIHdvcmtib29rT3B0aW9ucyhleHBvcnREYXRhKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRFeHBvcnREYXRhKGV4cG9ydERhdGEpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gd29ya2Jvb2tPcHRpb25zKHtcbiAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcbiAgICAgICAgICAgIGRhdGE6IGN1cnJlbnREYXRhLmRhdGEsXG4gICAgICAgICAgICBncm91cDogY3VycmVudERhdGEuZ3JvdXAsXG4gICAgICAgICAgICBmaWx0ZXJhYmxlOiB0aGlzLmZpbHRlcmFibGUsXG4gICAgICAgICAgICBjcmVhdG9yOiB0aGlzLmNyZWF0b3IsXG4gICAgICAgICAgICBkYXRlOiB0aGlzLmRhdGUsXG4gICAgICAgICAgICBydGw6IHRoaXMubG9jYWxpemF0aW9uLnJ0bCxcbiAgICAgICAgICAgIHBhZGRpbmdDZWxsT3B0aW9uczogdGhpcy5wYWRkaW5nQ2VsbE9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnM6IHRoaXMuaGVhZGVyUGFkZGluZ0NlbGxPcHRpb25zLFxuICAgICAgICAgICAgY29sbGFwc2libGU6IHRoaXMuY29sbGFwc2libGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGZpbGUgZGF0YSBVUklcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGZpbGVzYXZpbmdfZXhjZWxleHBvcnQgJX0pKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHBvcnREYXRhIC0gVGhlIG9wdGlvbmFsIGRhdGEgb3IgW2BXb3JrYm9va09wdGlvbnNgXSh7JSBzbHVnIGFwaV9leGNlbC1leHBvcnRfd29ya2Jvb2tvcHRpb25zICV9KSB0aGF0IHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZGF0YSBVUkkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBUaGUgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgYnkgdGhlIGZpbGUgZGF0YSBVUkkuXG4gICAgICovXG4gICAgdG9EYXRhVVJMKGV4cG9ydERhdGEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGlzV29ya2Jvb2tPcHRpb25zKGV4cG9ydERhdGEpID9cbiAgICAgICAgICAgIGV4cG9ydERhdGEgOlxuICAgICAgICAgICAgdGhpcy53b3JrYm9va09wdGlvbnMoZXhwb3J0RGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdG9EYXRhVVJMKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZ2V0RXhwb3J0RGF0YShleHBvcnREYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChleHBvcnREYXRhKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHBvcnREYXRhKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXhwb3J0RGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHBvcnREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgICAgICBncm91cDogdGhpcy5ncm91cFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzYXZlRmlsZShkYXRhVVJMKSB7XG4gICAgICAgIHNhdmVBcyhkYXRhVVJMLCB0aGlzLmZpbGVOYW1lLCB7XG4gICAgICAgICAgICBmb3JjZVByb3h5OiB0aGlzLmZvcmNlUHJveHksXG4gICAgICAgICAgICBwcm94eVVSTDogdGhpcy5wcm94eVVSTFxuICAgICAgICB9KTtcbiAgICB9XG59XG5FeGNlbEV4cG9ydENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAna2VuZG9FeGNlbEV4cG9ydCcsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1leGNlbGV4cG9ydCcsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5leGNlbGV4cG9ydCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkV4Y2VsRXhwb3J0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5FeGNlbEV4cG9ydENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmaWxlTmFtZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyYWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29sbGFwc2libGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNyZWF0b3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZvcmNlUHJveHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHByb3h5VVJMOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRhOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBncm91cDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFkZGluZ0NlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoZWFkZXJQYWRkaW5nQ2VsbE9wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbHVtbnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0NvbHVtbkJhc2UsIHsgZGVzY2VuZGFudHM6IHRydWUgfSxdIH1dXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGdyb3VwIGhlYWRlciBjZWxsIHRlbXBsYXRlIG9mIHRoZSBFeGNlbCBFeHBvcnQgY29sdW1uIGNvbXBvbmVudFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjb2x1bW5zX2V4Y2VsLWV4cG9ydCAlfSN0b2MtZ3JvdXAtaGVhZGVyLXRlbXBsYXRlKSkuXG4gKiBFbmFibGVzIHlvdSB0byBjdXN0b21pemUgdGhlIGNvbnRlbnQgb2YgdGhlIGdyb3VwIGhlYWRlciBpdGVtLlxuICovXG5jbGFzcyBHcm91cEhlYWRlclRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRXhjZWxFeHBvcnRHcm91cEhlYWRlclRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGdyb3VwIGhlYWRlciBjb2x1bW4gdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1ncm91cC1oZWFkZXItY29sdW1uLXRlbXBsYXRlKSkuXG4gKi9cbmNsYXNzIEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Hcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FeGNlbEV4cG9ydEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Hcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZ3JvdXAgZm9vdGVyIGNlbGwgdGVtcGxhdGUgb2YgdGhlIEV4Y2VsIEV4cG9ydCBjb2x1bW4gY29tcG9uZW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNvbHVtbnNfZXhjZWwtZXhwb3J0ICV9I3RvYy1ncm91cC1mb290ZXItdGVtcGxhdGUpKS5cbiAqIEVuYWJsZXMgeW91IHRvIGN1c3RvbWl6ZSB0aGUgZ3JvdXAgZm9vdGVyIGNlbGwgb2YgdGhlIGNvbHVtbi5cbiAqL1xuY2xhc3MgR3JvdXBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V4Y2VsRXhwb3J0R3JvdXBGb290ZXJUZW1wbGF0ZV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBmb290ZXIgY2VsbCB0ZW1wbGF0ZSBvZiB0aGUgRXhjZWwgRXhwb3J0IGNvbHVtbiBjb21wb25lbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY29sdW1uc19leGNlbC1leHBvcnQgJX0jdG9jLWZvb3Rlci10ZW1wbGF0ZSkpLlxuICogRW5hYmxlcyB5b3UgdG8gY3VzdG9taXplIHRoZSBmb290ZXIgY2VsbCBvZiB0aGUgY29sdW1uLlxuICovXG5jbGFzcyBGb290ZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbkZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9FeGNlbEV4cG9ydEZvb3RlclRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb2x1bW5zIG9mIHRoZSBLZW5kbyBVSSBFeGNlbCBFeHBvcnQgY29tcG9uZW50IGZvciBBbmd1bGFyLlxuICovXG5jbGFzcyBDb2x1bW5Db21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICB9XG59XG5Db2x1bW5Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ29sdW1uQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbHVtbkNvbXBvbmVudCkgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1mb3J3YXJkLXJlZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWV4Y2VsZXhwb3J0LWNvbHVtbicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNvbHVtbkNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbHVtbkJhc2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IFNraXBTZWxmIH0sIHsgdHlwZTogSG9zdCB9LCB7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5Db2x1bW5Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBncm91cEhlYWRlckNlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBncm91cEZvb3RlckNlbGxPcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb290ZXJDZWxsT3B0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZ3JvdXBIZWFkZXJUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIGdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0dyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBncm91cEZvb3RlclRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtHcm91cEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZm9vdGVyVGVtcGxhdGU6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0Zvb3RlclRlbXBsYXRlRGlyZWN0aXZlLF0gfV1cbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY29sdW1uIGdyb3VwIGNvbXBvbmVudCBvZiB0aGUgS2VuZG8gVUkgRXhjZWwgRXhwb3J0IGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgQ29sdW1uR3JvdXBDb21wb25lbnQgZXh0ZW5kcyBDb2x1bW5CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxufVxuQ29sdW1uR3JvdXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ29sdW1uQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENvbHVtbkdyb3VwQ29tcG9uZW50KSAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAna2VuZG8tZXhjZWxleHBvcnQtY29sdW1uLWdyb3VwJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ29sdW1uR3JvdXBDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDb2x1bW5CYXNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBTa2lwU2VsZiB9LCB7IHR5cGU6IEhvc3QgfSwgeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgRXhjZWxFeHBvcnRDb21wb25lbnQsXG4gICAgQ29sdW1uQ29tcG9uZW50LFxuICAgIENvbHVtbkdyb3VwQ29tcG9uZW50LFxuICAgIEZvb3RlclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgR3JvdXBIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBHcm91cEhlYWRlckNvbHVtblRlbXBsYXRlRGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgRXhjZWwgRXhwb3J0IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBFeGNlbEV4cG9ydE1vZHVsZSBtb2R1bGVcbiAqIGltcG9ydCB7IEV4Y2VsRXhwb3J0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItZXhjZWwtZXhwb3J0JztcbiAqXG4gKiAvLyBUaGUgYnJvd3NlciBwbGF0Zm9ybSB3aXRoIGEgY29tcGlsZXJcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICpcbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogLy8gSW1wb3J0IHRoZSBhcHAgY29tcG9uZW50XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIC8vIERlZmluZSB0aGUgYXBwIG1vZHVsZVxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSwgLy8gZGVjbGFyZSBhcHAgY29tcG9uZW50XG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgRXhjZWxFeHBvcnRNb2R1bGVdLCAvLyBpbXBvcnQgRXhjZWxFeHBvcnRNb2R1bGUgbW9kdWxlXG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqXG4gKiAvLyBDb21waWxlIGFuZCBsYXVuY2ggdGhlIG1vZHVsZVxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBFeGNlbEV4cG9ydE1vZHVsZSB7XG59XG5FeGNlbEV4cG9ydE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbZGVjbGFyYXRpb25zXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbZGVjbGFyYXRpb25zXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEdyb3VwSGVhZGVyQ29sdW1uVGVtcGxhdGVEaXJlY3RpdmUsIEV4Y2VsRXhwb3J0Q29tcG9uZW50LCBFeGNlbEV4cG9ydE1vZHVsZSwgQ29sdW1uQmFzZSwgQ29sdW1uQ29tcG9uZW50LCBDb2x1bW5Hcm91cENvbXBvbmVudCwgRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIEdyb3VwRm9vdGVyVGVtcGxhdGVEaXJlY3RpdmUsIEdyb3VwSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIHdvcmtib29rT3B0aW9ucywgdG9EYXRhVVJMLCBpc1dvcmtib29rT3B0aW9ucyB9O1xuIl19